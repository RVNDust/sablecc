/* This file was generated by SableCC's ObjectMacro. */

package org.sablecc.objectmacro.codegeneration.c.macro;

import java.util.*;

public class MMapC extends Macro{
    
    
    
    
    
    public MMapC(){
    
    
    }
    
    
    
    
    
    
    
    
    
    
    
    @Override
     void apply(
             InternalsInitializer internalsInitializer){
    
         internalsInitializer.setMapC(this);
     }
    
    
    @Override
    public String build(){
    
        BuildState buildState = this.build_state;
    
        if(buildState == null){
            buildState = new BuildState();
        }
        else if(buildState.getExpansion() == null){
            throw ObjectMacroException.cyclicReference("MapC");
        }
        else{
            return buildState.getExpansion();
        }
        this.build_state = buildState;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();
    
        
        
    
        StringBuilder sb0 = new StringBuilder();
    
        sb0.append("/**");
        sb0.append(LINE_SEPARATOR);
        sb0.append(" * Copyright (c) 2014 rxi");
        sb0.append(LINE_SEPARATOR);
        sb0.append(" *");
        sb0.append(LINE_SEPARATOR);
        sb0.append(" * This library is free software; you can redistribute it and/or modify it");
        sb0.append(LINE_SEPARATOR);
        sb0.append(" * under the terms of the MIT license. See LICENSE for details.");
        sb0.append(LINE_SEPARATOR);
        sb0.append(" */");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("#");
        sb0.append("include <stdlib.h>");
        sb0.append(LINE_SEPARATOR);
        sb0.append("#");
        sb0.append("include <string.h>");
        sb0.append(LINE_SEPARATOR);
        sb0.append("#");
        sb0.append("include \"Map.h\"");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("struct map_node_t ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    unsigned hash;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    void *value;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t *next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    /* char key[]; */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    /* char value[]; */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("};");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("static unsigned map_hash(const char *str) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    unsigned hash = 5381;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    while (*str) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        hash = ((hash << 5) + hash) ^ *str++;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return hash;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("static map_node_t *map_newnode(const char *key, void *value, int vsize) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t *node;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    int ksize = strlen(key) + 1;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    int voffset = ksize + ((sizeof(void*) - ksize) % sizeof(void*));");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    node = malloc(sizeof(*node) + voffset + vsize);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (!node) return NULL;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    memcpy(node + 1, key, ksize);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    node->hash = map_hash(key);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    node->value = ((char*) (node + 1)) + voffset;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    memcpy(node->value, value, vsize);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return node;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("static int map_bucketidx(map_base_t *m, unsigned hash) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    /* If the implementation is changed to allow a non-power-of-2 bucket count,");
        sb0.append(LINE_SEPARATOR);
        sb0.append("     * the line below should be changed to use mod instead of AND */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return hash & (m->nbuckets - 1);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("static void map_addnode(map_base_t *m, map_node_t *node) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    int n = map_bucketidx(m, node->hash);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    node->next = m->buckets[n];");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    m->buckets[n] = node;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("static int map_resize(map_base_t *m, int nbuckets) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t *nodes, *node, *next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t **buckets;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    int i;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    /* Chain all nodes together */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    nodes = NULL;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    i = m->nbuckets;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    while (i--) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        node = (m->buckets)[i];");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        while (node) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            next = node->next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            node->next = nodes;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            nodes = node;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            node = next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    /* Reset buckets */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    buckets = realloc(m->buckets, sizeof(*m->buckets) * nbuckets);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (buckets != NULL) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        m->buckets = buckets;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        m->nbuckets = nbuckets;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (m->buckets) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        memset(m->buckets, 0, sizeof(*m->buckets) * m->nbuckets);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        /* Re-add nodes to buckets */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        node = nodes;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        while (node) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            next = node->next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            map_addnode(m, node);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            node = next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    /* Return error code if realloc() failed */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return (buckets == NULL) ? -1 : 0;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("static map_node_t **map_getref(map_base_t *m, const char *key) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    unsigned hash = map_hash(key);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t **next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (m->nbuckets > 0) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        next = &m->buckets[map_bucketidx(m, hash)];");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        while (*next) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            if ((*next)->hash == hash && !strcmp((char*) (*next + 1), key)) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("                return next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            next = &(*next)->next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return NULL;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("void map_deinit_(map_base_t *m) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t *next, *node;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    int i;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    i = m->nbuckets;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    while (i--) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        node = m->buckets[i];");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        while (node) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            next = node->next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            free(node);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            node = next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    free(m->buckets);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("void *map_get_(map_base_t *m, const char *key) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t **next = map_getref(m, key);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return next ? (*next)->value : NULL;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("int map_set_(map_base_t *m, const char *key, void *value, int vsize) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    int n, err;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t **next, *node;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    /* Find & replace existing node */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    next = map_getref(m, key);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (next) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        memcpy((*next)->value, value, vsize);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        return 0;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    /* Add new node */");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    node = map_newnode(key, value, vsize);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (node == NULL) goto fail;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (m->nnodes >= m->nbuckets) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        n = (m->nbuckets > 0) ? (m->nbuckets << 1) : 1;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        err = map_resize(m, n);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        if (err) goto fail;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_addnode(m, node);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    m->nnodes++;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return 0;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    fail:");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (node) free(node);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return -1;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("void map_remove_(map_base_t *m, const char *key) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t *node;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_node_t **next = map_getref(m, key);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (next) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        node = *next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        *next = (*next)->next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        free(node);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        m->nnodes--;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("map_iter_t map_iter_(void) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    map_iter_t iter;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    iter.bucketidx = -1;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    iter.node = NULL;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return iter;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("const char *map_next_(map_base_t *m, map_iter_t *iter) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    if (iter->node) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        iter->node = iter->node->next;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        if (iter->node == NULL) goto nextBucket;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    } else ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        nextBucket:");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        do ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            if (++iter->bucketidx >= m->nbuckets) ");
        sb0.append("{");
        sb0.append(LINE_SEPARATOR);
        sb0.append("                return NULL;");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("            iter->node = m->buckets[iter->bucketidx];");
        sb0.append(LINE_SEPARATOR);
        sb0.append("        } while (iter->node == NULL);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    }");
        sb0.append(LINE_SEPARATOR);
        sb0.append("    return (char*) (iter->node + 1);");
        sb0.append(LINE_SEPARATOR);
        sb0.append("}");
    
        buildState.setExpansion(sb0.toString());
        return sb0.toString();
    }
    
    
    @Override
    String build(Context context) {
     return build();
    }
    private String applyIndent(
                            String macro,
                            String indent){

            StringBuilder sb = new StringBuilder();
            String[] lines = macro.split( "\n");

            if(lines.length > 1){
                for(int i = 0; i < lines.length; i++){
                    String line = lines[i];
                    sb.append(indent).append(line);

                    if(i < lines.length - 1){
                        sb.append(LINE_SEPARATOR);
                    }
                }
            }
            else{
                sb.append(indent).append(macro);
            }

            return sb.toString();
    }
}