#This file is part of SableCC ( http://sablecc.org ).
#
#See the NOTICE file distributed with this work for copyright information.
#
#Licensed under the Apache License, Version 2.0 (the "License");
#you may not use this file except in compliance with the License.
#You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#Unless required by applicable law or agreed to in writing, software
#distributed under the License is distributed on an "AS IS" BASIS,
#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#See the License for the specific language governing permissions and
#limitations under the License.

#============================
#========== Utils  ==========
#============================

#========== header ==========
Macro header
{Body}
/* This file was generated by SableCC's ObjectMacro. */
{End}

#========== include ==========
Macro include
    Param
        include_name : String;
{Body}
{#include "M{include_name}.h"
{End}

#========== line_separator ==========
Macro line_separator
{Body}
sb0->vt->append(sb0, "\\n");
{End}

#========== context_h ==========
Macro context_h
{Body}
{Insert: header}

{#ifndef CONTEXT_H
{#define CONTEXT_H

typedef struct Context
{
    char value[17];
} Context;

Context new_Context();
void free_Context(struct Context*);

{#endif //CONTEXT_H
{End}

#========== context_c ==========
Macro context_c
{Body}
{#include <stdio.h>
{#include <stdlib.h>

{#include "Context.h"

Context new_Context()
{
    Context context;
    sprintf(context.value, "%u", (const char*)&context);
    return context;
}

void free_Context(struct Context *this)
{
    free(this);
}
{End}

#========== internals_initializer_h =========
Macro internals_initializer_h
    Param
        parent_internals_setter_vt_h : parent_internals_setter_vt_h, separator="\n";
        parent_internals_setter_h : parent_internals_setter_h, separator="\n";
{Body}
{Insert: header}

{#ifndef INTERNALSINITIALIZER_H
{#define INTERNALSINITIALIZER_H

extern struct InternalsInitializer_VT VT_InternalsInitializer;
extern void *HT_InternalsInitializer[];

typedef struct InternalsInitializer
{
    struct InternalsInitializer_VT (*vt);
    char* paramName;
} InternalsInitializer;

typedef struct InternalsInitializer_VT
{
    int hl;
    void* (*ht)[];
{Indent: "\t"}
{parent_internals_setter_vt_h}
{End}
} InternalsInitializer_VT;

InternalsInitializer* new_InternalsInitializer(char* paramName);
void free_InternalsInitializer(struct InternalsInitializer*);

{parent_internals_setter_h}

{#endif //INTERNALSINITIALIZER_H
{End}

#========== redef_internals_initializer_h =========
Macro redef_internals_initializer_h
    Param
        redef_index : String;
        parent_internals_setter_vt_h : parent_internals_setter_vt_h, separator="\n";
        parent_internals_setter_h : parent_internals_setter_h, separator="\n";
{Body}
{Insert: header}

{#ifndef INTERNALSINITIALIZER_H
{#define INTERNALSINITIALIZER_H

extern struct InternalsInitializer_redef{redef_index}_VT VT_InternalsInitializer;
extern void *HT_InternalsInitializer[];

typedef struct InternalsInitializer_redef{redef_index}
{
    struct InternalsInitializer_redef{redef_index}_VT (*vt);
    char* paramName;
} InternalsInitializer_redef{redef_index};

typedef struct InternalsInitializer_redef{redef_index}_VT
{
    int hl;
    void* (*ht)[];
{Indent: "\t"}
{parent_internals_setter_vt_h}
{End}
} InternalsInitializer__redef{redef_index}VT;

InternalsInitializer_redef{redef_index}* new_InternalsInitializer(char* paramName);
void free_InternalsInitializer(struct InternalsInitializer_redef{redef_index}*);

{parent_internals_setter_h}

{#endif //INTERNALSINITIALIZER_H
{End}

#========== internals_initializer_c =========
Macro internals_initializer_c
    Param
        parent_internals_setter_c : parent_internals_setter_c, separator="\n";
        includes : include, separator="\n";
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>
{#include<string.h>

{#include "Stringbuilder.h"
{#include "LinkedList.h"
{#include "Map.h"
{#include "Context.h"
{#include "InternalValue.h"

{includes}

{#include "InternalsInitializer.h"


struct InternalsInitializer_VT VT_InternalsInitializer = {0, &HT_InternalsInitializer};
void* HT_InternalsInitializer[] = {&VT_InternalsInitializer};

InternalsInitializer* new_InternalsInitializer(char* paramName)
{
    InternalsInitializer* internalInitializer = malloc(sizeof(InternalsInitializer));
    internalInitializer->vt = &VT_InternalsInitializer;
    internalInitializer->paramName = paramName;
    return internalInitializer;
}


void free_InternalsInitializer(InternalsInitializer* this)
{
    //TODO
}

{parent_internals_setter_c}
{End}

#========== redef_internals_initializer_c =========
Macro redef_internals_initializer_c
    Param
        redef_index : String;
        redef_parent_internals_setter_c : redef_parent_internals_setter_c(redef_index), separator="\n";
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>
{#include<string.h>

{#include "InternalsInitializer_redef{redef_index}.h"

struct InternalsInitializer_redef{redef_index}_VT VT_InternalsInitializer = {0, &HT_InternalsInitializer};
void* HT_InternalsInitializer[] = {&VT_InternalsInitializer};

InternalsInitializer_redef{redef_index}* new_InternalsInitializer(char* paramName)
{
    InternalsInitializer_redef{redef_index}* internalInitializer = malloc(sizeof(InternalsInitializer_redef{redef_index}));
    internalInitializer->vt = &VT_InternalsInitializer;
    internalInitializer->paramName = paramName;
    return internalInitializer;
}


void free_InternalsInitializer(InternalsInitializer_redef{redef_index}* this)
{
    //TODO
}

{redef_parent_internals_setter_c}
{End}

#========== parent_internals_setter_vt_h =========
Macro parent_internals_setter_vt_h
    Param
        name : String;
{Body}
void (*set{name})(InternalsInitializer *this, struct M{name}*);
{End}

#========== parent_internals_setter_h =========
Macro parent_internals_setter_h
    Param
        name : String;
{Body}
void InternalsInitializer_set{name}(InternalsInitializer *this, struct M{name}*);
{End}

#========== parent_internals_setter_c =========
Macro parent_internals_setter_c
    Param
        name : String;
{Body}
void InternalsInitializer_set{name}(InternalsInitializer *this, M{name} *m{name})
{
    exit(1);
}
{End}

#========== redef_parent_internals_setter_c =========
Macro redef_parent_internals_setter_c
    Param
        name : String;
        macro_body_parts : init_string_builder, string_part, param_insert_part(name), eol_part, insert_macro_part(name), separator="\n";
        set_internals : set_internal(name, redef_index);
    Internal
        redef_index : String;
{Body}
void InternalsInitializer_redef{redef_index}_set{name}(InternalsInitializer_redef{redef_index} *this, M{name} *m{name})
{
{Indent: "\t"}
{macro_body_parts}
{set_internals}
{End}
}
{End}

#========== linked_list_node_h ==========
Macro linked_list_node_h
{Body}
{Insert: header}

{#ifndef LINKEDLISTNODE_H
{#define LINKEDLISTNODE_H

typedef struct Node
{
    void *data;
    struct Node *next;
} Node;

Node* new_Node();
void free_Node(struct Node*);

{#endif //LINKEDLISTNODE_H
{End}

#========== linked_list_node_c ==========
Macro linked_list_node_c
{Body}
{Insert: header}

{#include <stdio.h>
{#include <stdlib.h>

{#include "LinkedListNode.h"

Node* new_Node()
{
    Node* node = malloc(sizeof(Node));
    node->data = NULL;
    node->next = NULL;
    return node;
}

void free_Node(Node* this)
{
    if(this != NULL)
    {
        free(this);
        this = NULL;
    }
}
{End}

#========== linked_list_h ==========
Macro linked_list_h
{Body}
{Insert: header}

{#ifndef LINKEDLIST_H
{#define LINKEDLIST_H

extern struct LinkedList_VT VT_LinkedList;
extern void *HT_LinkedList[];

typedef struct LinkedList
{
    struct LinkedList_VT (*vt);
    struct Node *nodes;
    unsigned int size;
} LinkedList;

typedef struct LinkedList_VT
{
    int hl;
    void* (*ht)[];
    void (*addFirst)(struct LinkedList*, void *new_data, size_t data_size);
    void (*addLast)(struct LinkedList*, void *new_data, size_t data_size);
    void (*addAtIndex)(struct LinkedList*, void *new_data, size_t data_size, unsigned int index);
    void* (*getAtIndex)(struct LinkedList*, unsigned int index);
    void (*removeFirst)(struct LinkedList*);
    void (*removeLast)(struct LinkedList*);
    void (*removeAtIndex)(struct LinkedList*, unsigned int index);
    char* (*toString)(struct LinkedList*);
} LinkedList_VT;

LinkedList* new_LinkedList();
void free_LinkedList(struct LinkedList*);

void LinkedList_addFirst(struct LinkedList*, void *new_data, size_t data_size);
void LinkedList_addLast(struct LinkedList*, void *new_data, size_t data_size);
void LinkedList_addAtIndex(struct LinkedList*, void *new_data, size_t data_size, unsigned int index);
void* LinkedList_getAtIndex(struct LinkedList*, unsigned int index);
void LinkedList_removeFirst(struct LinkedList*);
void LinkedList_removeLast(struct LinkedList*);
void LinkedList_removeAtIndex(struct LinkedList*, unsigned int index);
char* LinkedList_toString(struct LinkedList*);

{#endif //LINKEDLIST_H
{End}

#========== linked_list_c ==========
Macro linked_list_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>
{#include<string.h>

{#include "LinkedListNode.h"
{#include "LinkedList.h"

struct LinkedList_VT VT_LinkedList={0, &HT_LinkedList, &LinkedList_addFirst, &LinkedList_addLast, &LinkedList_addAtIndex, &LinkedList_getAtIndex, &LinkedList_removeFirst, &LinkedList_removeLast, &LinkedList_removeAtIndex, &LinkedList_toString};
void* HT_LinkedList[] = {&VT_LinkedList};

LinkedList* new_LinkedList()
{
    LinkedList* linkedList = malloc(sizeof(LinkedList));
    linkedList->vt = &VT_LinkedList;
    linkedList->nodes = NULL;
    linkedList->size = 0;
    return linkedList;
}

void free_LinkedList(LinkedList* this)
{
    //TODO
}

void LinkedList_addFirst(LinkedList* this, void *new_data, size_t data_size)
{
    this->vt->addAtIndex(this, new_data, data_size, 0);
}

void LinkedList_addLast(LinkedList* this, void *new_data, size_t data_size)
{
    this->vt->addAtIndex(this, new_data, data_size, this->size);
}

void LinkedList_addAtIndex(LinkedList* this, void *new_data, size_t data_size, unsigned int index)
{
    if(index <= this->size)
    {
        struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
        new_node->data = malloc(data_size);
        new_node->data = new_data;

        if(this->nodes != NULL)
        {
            Node* prevNode = NULL;
            Node* currentNode = this->nodes;

            if(index == 0)
            {
                new_node->next = currentNode;
                this->nodes = new_node;
            }
            else
            {
                for(int i = 0; i < index; i++)
                {
                    prevNode = currentNode;
                    currentNode = currentNode->next;
                }

                prevNode->next = new_node;
                new_node->next = currentNode;
            }
        }
        else
        {
            this->nodes = new_node;
        }

        this->size = this->size + 1;
    }
    else
    {
        exit(1);
    }
}

void* LinkedList_getAtIndex(LinkedList* this, unsigned int index)
{
    if(index <= this->size)
    {
        if(this->nodes != NULL)
        {
            Node* prevNode = NULL;
            Node* currentNode = this->nodes;
            if(index == 0)
            {
                return this->nodes->data;
            }
            else
            {
                for(int i = 0; i < index; i++)
                {
                    prevNode = currentNode;
                    currentNode = currentNode->next;
                }

                return currentNode->data;
            }
        }
        exit(1);
    }
    else
    {
        exit(1);
    }
}

void LinkedList_removeFirst(LinkedList* this)
{
    this->vt->removeAtIndex(this, 0);
}

void LinkedList_removeLast(LinkedList* this)
{
    this->vt->removeAtIndex(this, this->size);
}

void LinkedList_removeAtIndex(LinkedList* this, unsigned int index)
{
    if(index <= this->size)
    {
        if(this->nodes != NULL)
        {
            Node* prevNode = NULL;
            Node* currentNode = this->nodes;
            if(index == 1)
            {
                this->nodes = NULL;
            }
            else
            {
                for(int i = 0; i < index; i++)
                {
                    prevNode = currentNode;
                    currentNode = currentNode->next;
                }

                if(index < this->size-1)
                {
                    prevNode->next = currentNode->next;
                }
            }
            free_Node(currentNode);
            this->size = this->size - 1;
        }
    }
    else
    {
        exit(1);
    }
}

char* LinkedList_toString(LinkedList* this)
{
    Node *currentNode = this->nodes;
    int currentTextSize = 1;

    if(currentNode != NULL)
    {
        void *current_data = NULL;
        for(int i = 0; i < this->size; i++)
        {
            current_data = currentNode->data;
            //int textSize = strlen((char*)current_data);
            int textSize = sizeof(current_data);
            currentTextSize = currentTextSize + textSize;

            currentNode = currentNode->next;
        }

        char *currentText = calloc(currentTextSize, sizeof(char));
        strcpy(currentText, "");
        //char *currentText = "";

        currentNode = this->nodes;

        for(int i = 0; i < this->size; i++)
        {
            current_data = currentNode->data;
            strcat(currentText, (const char*)current_data);
            currentNode = currentNode->next;
        }

        return currentText;
    }

    return "";
}

{End}

#========== string_builder_h ==========
Macro string_builder_h
{Body}
{Insert: header}

{#ifndef STRINGBUILDER_H
{#define STRINGBUILDER_H

{#include <stddef.h>
{#include <stdbool.h>

extern struct Stringbuilder_VT VT_Stringbuilder;
extern void *HT_Stringbuilder[];
static const char LINE_SEPARATOR[] = "\\n";

typedef struct Stringbuilder
{
    struct Stringbuilder_VT (*vt);
    char* mem;
    size_t count;
    size_t cap;
} Stringbuilder;

typedef struct Stringbuilder_VT
{
    int hl;
    void* (*ht)[];
    bool (*append)(struct Stringbuilder*, char*);
    char* (*toString)(struct Stringbuilder*);
} Stringbuilder_VT;

Stringbuilder* new_Stringbuilder(size_t init_cap);
void free_Stringbuilder(struct Stringbuilder*);

bool Stringbuilder_append(struct Stringbuilder*, char*);
bool Stringbuilder_appendChar(struct Stringbuilder*, char);
char* Stringbuilder_toString(struct Stringbuilder*);

{#endif //STRINGBUILDER_H
{End}


#========== string_builder_c ==========
Macro string_builder_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>
{#include<string.h>

{#include "Stringbuilder.h"

struct Stringbuilder_VT VT_Stringbuilder={0, &HT_Stringbuilder, &Stringbuilder_append, &Stringbuilder_toString};
void* HT_Stringbuilder[] = {&VT_Stringbuilder};

Stringbuilder* new_Stringbuilder(size_t init_cap)
{
    Stringbuilder* ret = malloc(sizeof(struct Stringbuilder));
    ret->vt = &VT_Stringbuilder;
    if (!ret) return NULL;
    ret->mem = calloc(init_cap, sizeof(char));
    if (!ret->mem) return NULL;
    ret->cap = init_cap;
    ret->count = 0;
    return ret;
}

void free_Stringbuilder(Stringbuilder* this)
{
    free(this->mem);
    free(this);
    this = NULL;
}

{#define LOAD_FACTOR 2
bool Stringbuilder_append(Stringbuilder *this, char* string)
{
    bool size_ok = true;
    int len = strlen(string);
    for(int i = 0; i < len; i++)
    {
        size_ok = Stringbuilder_appendChar(this, string[i]);
    }
    return size_ok;
}

bool Stringbuilder_appendChar(Stringbuilder *this, char c) {
    this->mem[this->count] = c;
    ++this->count;
    if (this->count == this->cap) {
        char *new_mem = realloc(this->mem, this->cap * LOAD_FACTOR);
        if (!new_mem) {
            return false;
        }
        memset(new_mem + this->cap, 0, this->cap);
        this->mem = new_mem;
        this->cap *= LOAD_FACTOR;
    }
    return true;
}

char* Stringbuilder_toString(Stringbuilder *this) {
    return this->mem;
}
{End}

#========== map_h ==========
Macro map_h
{Body}
/**
 * Copyright (c) 2014 rxi
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the MIT license. See LICENSE for details.
 */

{#ifndef MAP_H
{#define MAP_H

{#include <string.h>

{#define MAP_VERSION "0.1.0"

struct map_node_t;
typedef struct map_node_t map_node_t;

typedef struct {
    map_node_t **buckets;
    unsigned nbuckets, nnodes;
} map_base_t;

typedef struct {
    unsigned bucketidx;
    map_node_t *node;
} map_iter_t;


{#define map_t(T)\\
  struct { map_base_t base; T *ref; T tmp; }


{#define map_init(m)\\
  memset(m, 0, sizeof(*(m)))


{#define map_deinit(m)\\
  map_deinit_(&(m)->base)


{#define map_get(m, key)\\
  ( (m)->ref = map_get_(&(m)->base, key) )


{#define map_set(m, key, value)\\
  ( (m)->tmp = (value),\\
    map_set_(&(m)->base, key, &(m)->tmp, sizeof((m)->tmp)) )


{#define map_remove(m, key)\\
  map_remove_(&(m)->base, key)


{#define map_iter(m)\\
  map_iter_()


{#define map_next(m, iter)\\
  map_next_(&(m)->base, iter)


void map_deinit_(map_base_t *m);
void *map_get_(map_base_t *m, const char *key);
int map_set_(map_base_t *m, const char *key, void *value, int vsize);
void map_remove_(map_base_t *m, const char *key);
map_iter_t map_iter_(void);
const char *map_next_(map_base_t *m, map_iter_t *iter);


typedef map_t(void*) map_void_t;
typedef map_t(char*) map_str_t;
typedef map_t(int) map_int_t;
typedef map_t(char) map_char_t;
typedef map_t(float) map_float_t;
typedef map_t(double) map_double_t;

{#endif
{End}

#========== map_c ==========
Macro map_c
{Body}
/**
 * Copyright (c) 2014 rxi
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the MIT license. See LICENSE for details.
 */

{#include <stdlib.h>
{#include <string.h>
{#include "Map.h"

struct map_node_t {
    unsigned hash;
    void *value;
    map_node_t *next;
    /* char key[]; */
    /* char value[]; */
};


static unsigned map_hash(const char *str) {
    unsigned hash = 5381;
    while (*str) {
        hash = ((hash << 5) + hash) ^ *str++;
    }
    return hash;
}


static map_node_t *map_newnode(const char *key, void *value, int vsize) {
    map_node_t *node;
    int ksize = strlen(key) + 1;
    int voffset = ksize + ((sizeof(void*) - ksize) % sizeof(void*));
    node = malloc(sizeof(*node) + voffset + vsize);
    if (!node) return NULL;
    memcpy(node + 1, key, ksize);
    node->hash = map_hash(key);
    node->value = ((char*) (node + 1)) + voffset;
    memcpy(node->value, value, vsize);
    return node;
}


static int map_bucketidx(map_base_t *m, unsigned hash) {
    /* If the implementation is changed to allow a non-power-of-2 bucket count,
     * the line below should be changed to use mod instead of AND */
    return hash & (m->nbuckets - 1);
}


static void map_addnode(map_base_t *m, map_node_t *node) {
    int n = map_bucketidx(m, node->hash);
    node->next = m->buckets[n];
    m->buckets[n] = node;
}


static int map_resize(map_base_t *m, int nbuckets) {
    map_node_t *nodes, *node, *next;
    map_node_t **buckets;
    int i;
    /* Chain all nodes together */
    nodes = NULL;
    i = m->nbuckets;
    while (i--) {
        node = (m->buckets)[i];
        while (node) {
            next = node->next;
            node->next = nodes;
            nodes = node;
            node = next;
        }
    }
    /* Reset buckets */
    buckets = realloc(m->buckets, sizeof(*m->buckets) * nbuckets);
    if (buckets != NULL) {
        m->buckets = buckets;
        m->nbuckets = nbuckets;
    }
    if (m->buckets) {
        memset(m->buckets, 0, sizeof(*m->buckets) * m->nbuckets);
        /* Re-add nodes to buckets */
        node = nodes;
        while (node) {
            next = node->next;
            map_addnode(m, node);
            node = next;
        }
    }
    /* Return error code if realloc() failed */
    return (buckets == NULL) ? -1 : 0;
}


static map_node_t **map_getref(map_base_t *m, const char *key) {
    unsigned hash = map_hash(key);
    map_node_t **next;
    if (m->nbuckets > 0) {
        next = &m->buckets[map_bucketidx(m, hash)];
        while (*next) {
            if ((*next)->hash == hash && !strcmp((char*) (*next + 1), key)) {
                return next;
            }
            next = &(*next)->next;
        }
    }
    return NULL;
}


void map_deinit_(map_base_t *m) {
    map_node_t *next, *node;
    int i;
    i = m->nbuckets;
    while (i--) {
        node = m->buckets[i];
        while (node) {
            next = node->next;
            free(node);
            node = next;
        }
    }
    free(m->buckets);
}


void *map_get_(map_base_t *m, const char *key) {
    map_node_t **next = map_getref(m, key);
    return next ? (*next)->value : NULL;
}


int map_set_(map_base_t *m, const char *key, void *value, int vsize) {
    int n, err;
    map_node_t **next, *node;
    /* Find & replace existing node */
    next = map_getref(m, key);
    if (next) {
        memcpy((*next)->value, value, vsize);
        return 0;
    }
    /* Add new node */
    node = map_newnode(key, value, vsize);
    if (node == NULL) goto fail;
    if (m->nnodes >= m->nbuckets) {
        n = (m->nbuckets > 0) ? (m->nbuckets << 1) : 1;
        err = map_resize(m, n);
        if (err) goto fail;
    }
    map_addnode(m, node);
    m->nnodes++;
    return 0;
    fail:
    if (node) free(node);
    return -1;
}


void map_remove_(map_base_t *m, const char *key) {
    map_node_t *node;
    map_node_t **next = map_getref(m, key);
    if (next) {
        node = *next;
        *next = (*next)->next;
        free(node);
        m->nnodes--;
    }
}


map_iter_t map_iter_(void) {
    map_iter_t iter;
    iter.bucketidx = -1;
    iter.node = NULL;
    return iter;
}


const char *map_next_(map_base_t *m, map_iter_t *iter) {
    if (iter->node) {
        iter->node = iter->node->next;
        if (iter->node == NULL) goto nextBucket;
    } else {
        nextBucket:
        do {
            if (++iter->bucketidx >= m->nbuckets) {
                return NULL;
            }
            iter->node = m->buckets[iter->bucketidx];
        } while (iter->node == NULL);
    }
    return (char*) (iter->node + 1);
}
{End}

#========== str_split_function_h ==========
Macro str_split_function_h
    Internal
        macro_name : String;
{Body}
char** M{macro_name}_strSplit(char* a_str, const char a_delim);
{End}

#========== str_split_function_c ==========
Macro str_split_function_c
    Internal
        macro_name : String;
{Body}
char** M{macro_name}_strSplit(char* a_str, const char a_delim)
{
    char** result    = 0;
    size_t count     = 0;
    char* tmp        = a_str;
    char* last_comma = 0;
    char delim[2];
    delim[0] = a_delim;
    delim[1] = 0;

    /* Count how many elements will be extracted. */
    while (*tmp)
    {
        if (a_delim == *tmp)
        {
            count++;
            last_comma = tmp;
        }
        tmp++;
    }

    /* Add space for trailing token. */
    count += last_comma < (a_str + strlen(a_str) - 1);

    /* Add space for terminating NULL string so caller
       knows where the list of returned strings ends. */
    count++;

    result = malloc(sizeof(char*) * count);

    if (result)
    {
        size_t idx  = 0;
        char* token = strtok(a_str, delim);

        while (token)
        {
            assert(idx < count);
            *(result + idx++) = strdup(token);
            token = strtok(0, delim);
        }
        assert(idx == count - 1);
        *(result + idx) = 0;
    }

    return result;
}
{End}

#========== class_internal_value_h ==========
Macro class_internal_value_h
{Body}
{Insert: header}

{#ifndef INTERNALVALUE_H
{#define INTERNALVALUE_H

extern struct InternalValue_VT VT_InternalValue;
extern void *HT_InternalValue[];

typedef struct InternalValue
{
    struct InternalValue_VT (*vt);
    LinkedList *macros;
    struct DAfterLast *dAfterLast;
    struct DBeforeFirst *dBeforeFirst;
    struct DSeparator *dSeparator;
    struct DNone *dNone;
    Context context;
    char* cache;
} InternalValue;

typedef struct InternalValue_VT
{
    int hl;
    void* (*ht)[];
    char* (*build)(struct InternalValue*);
    void (*setNone)(struct InternalValue*, struct DNone*);
    void (*setBeforeFirst)(struct InternalValue*, struct DBeforeFirst*);
    void (*setAfterLast)(struct InternalValue*, struct DAfterLast*);
    void (*setSeparator)(struct InternalValue*, struct DSeparator*);
} InternalValue_VT;

InternalValue* new_InternalValue(LinkedList *macros, Context context);
void free_InternalValue(struct InternalValue*);

char* InternalValue_build(struct InternalValue*);
void InternalValue_setNone(struct InternalValue*, struct DNone*);
void InternalValue_setBeforeFirst(struct InternalValue*, struct DBeforeFirst*);
void InternalValue_setAfterLast(struct InternalValue*, struct DAfterLast*);
void InternalValue_setSeparator(struct InternalValue*, struct DSeparator*);

{#endif //INTERNALVALUE_H

{End}

#========== class_internal_value_c ==========
Macro class_internal_value_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "DNone.h"
{#include "DBeforeFirst.h"
{#include "DAfterLast.h"
{#include "DSeparator.h"

{#include "InternalValue.h"

struct InternalValue_VT VT_InternalValue = {0, &HT_InternalValue, &InternalValue_build, &InternalValue_setNone, &InternalValue_setBeforeFirst, &InternalValue_AfterLast, &InternalValue_Separator};
void* HT_InternalValue[] = {&VT_InternalValue};

InternalValue* new_InternalValue(LinkedList *macros, Context context)
{
    InternalValue* internalValue = malloc(sizeof(InternalValue));
    internalValue->vt = &VT_InternalValue;
    internalValue->macros = macros;
    internalValue->context = context;
    return internalValue;
}

void free_InternalValue(InternalValue* this)
{

}

char* InternalValue_build(InternalValue* this)
{
    if(this->cache != NULL){
            return this->cache;
        }

        Stringbuilder *sb = new_Stringbuilder();
        int i = 0;
        int nb_macros = this->macros->size;

        if(this->dNone != NULL){
            sb->append(sb, this->dNone->apply(this->dNone, i, "", nb_macros));
        }

        for(i = 0; i < nb_macros; i++){
            char* expansion = macro->vt->build(this->context);

            if(this->dBeforeFirst != NULL){
                expansion = this->dBeforeFirst->apply(this->dBeforeFirst, i, expansion, nb_macros);
            }

            if(this->dAfterLast != NULL){
                expansion = this->dAfterLast->apply(this->dAfterLast, i, expansion, nb_macros);
            }

            if(this->dSeparator != NULL){
                expansion = this->dSeparator->apply(this->dSeparator, i, expansion, nb_macros);
            }

            sb->vt->append(sb, expansion);
        }

        this->cache = sb->vt->toString(sb);
        return this->cache;
}

void InternalValue_setNone(InternalValue* this, DNone* directive)
{
    this->dNone = directive;
}

void InternalValue_setBeforeFirst(InternalValue* this, DBeforeFirst* directive)
{
    this->dBeforeFirst = directive;
}

void InternalValue_setAfterLast(InternalValue* this, DAfterLast* directive)
{
    this->dAfterLast = directive;
}

void InternalValue_setSeparator(InternalValue* this, DSeparator* directive)
{
    this->dSeparator = directive;
}

{End}

#============================
#========== Basics   ========
#============================

#========== super_macro_h ==========
Macro super_macro_h
{Body}
{Insert: header}

{#ifndef MACRO_H
{#define MACRO_H

extern struct Macro_VT VT_Macro;
extern void *HT_Macro[];
extern char* LINE_SEPARATOR = "\\n";

typedef struct Macro
{
    struct Macro_VT (*vt);
    struct LinkedList *children;
} Macro;

typedef struct Macro_VT
{
    int hl;
    void* (*ht)[];
    char* (*build)(struct Macro*);
    void (*apply)(struct Macro*, struct InternalsInitializer*);
    struct LinkedList* (*getChildren)(struct Macro*);
} Macro_VT;

Macro* new_Macro();
void free_Macro(Macro*);

char* Macro_build(struct Macro*);
void Macro_apply(struct Macro*, struct InternalsInitializer*);
struct LinkedList* Macro_getChildren(struct Macro*);

{#endif //MACRO_H
{End}

#========== super_macro_c ==========
Macro super_macro_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "Macro.h"

struct Macro_VT VT_Macro = {0, &HT_Macro, &Macro_build, &Macro_apply, &Macro_getChildren};
void* HT_Macro[] = {&VT_Macro};

Macro* new_Macro()
{
    Macro* macro = malloc(sizeof(Macro));
    macro->vt = &VT_Macro;
    return macro;
}

void free_Macro(Macro* this)
{
    free(this);
}

char* Macro_build(Macro* this)
{
    exit(1);
}

void Macro_apply(Macro* this,InternalsInitializer* visitor)
{
    exit(1);
}


LinkedList* Macro_getChildren(Macro* this)
{
    return this->children;
}

{End}

#========== macro_h ==========
Macro macro_h
    Param
        macro_name : String;
        fields : field_string_declaration, field_macro_declaration, internal_field_declaration, directive_fields_declaration, internal_macros_value_field, separator="\n";
        context_fields : context_field, before_first="\n", separator="\n";
        constructor : constructor_h(macro_name);
        context_param : context_param, before_first=", ";
        methods : add_string_vt_h(macro_name), add_macro_vt_h(macro_name), internal_string_setter_vt_h(macro_name), internal_string_getter_vt_h(macro_name), internal_macro_setter_vt_h(macro_name), param_macro_ref_vt_h(macro_name), internal_macro_ref_vt_h(macro_name), separator="\n";
        init_directives : init_directives_h(macro_name), separator="\n", before_first="\n";
        str_split_function : str_split_function_h(macro_name), separator="\n", before_first="\n";
        functions : add_string_h(macro_name), add_macro_h(macro_name), internal_string_setter_h(macro_name), internal_string_getter_h(macro_name), internal_macro_setter_h(macro_name), param_macro_ref_h(macro_name), internal_macro_ref_h(macro_name), param_ref_builder_h(macro_name), internal_ref_builder_h(macro_name), separator="\n";
{Body}
{#ifndef M{macro_name}_H
{#define M{macro_name}_H

extern struct M{macro_name}_VT VT_M{macro_name};
extern void *HT_M{macro_name}[];

typedef struct M{macro_name}
{
    struct M{macro_name}_VT (*vt);
    struct LinkedList *children;
    struct Context context;
{Indent: "\t"}
{fields}
{context_fields}
{End}
} M{macro_name};

typedef struct M{macro_name}_VT
{
    int hl;
    void* (*ht)[];
    char* (*build)(struct M{macro_name}*{context_param});
    void (*apply)(struct M{macro_name}*, struct InternalsInitializer* visitor);
    struct LinkedList* (*getChildren)(struct M{macro_name}*);
{Indent: "\t"}
{methods}
{End}
} M{macro_name}_VT;

{constructor}

{init_directives}
{str_split_function}
{functions}

void free_M{macro_name}(struct M{macro_name}*);
char* M{macro_name}_build(struct M{macro_name}*{context_param});
void M{macro_name}_apply(struct M{macro_name}*, struct InternalsInitializer* visitor);
struct LinkedList* M{macro_name}_getChildren(struct M{macro_name}*);

{#endif //M{macro_name}_H
{End}

#========== macro_c ==========
Macro macro_c
    Param
        macro_name : String;
        includes : include, separator="\n";
        constructor : constructor_c(macro_name);
        function_names :  function_refs(macro_name) ,before_first=" ,", separator=" ,";
        functions : add_string_c(macro_name), add_macro_c(macro_name), internal_string_setter(macro_name), param_macro_ref_c(macro_name), internal_macro_setter(macro_name), internal_macro_ref_c(macro_name), before_first="\n", separator="\n";
        str_split_function : str_split_function_c(macro_name), separator="\n", before_first="\n";
        internal_functions : param_string_ref_builder(macro_name), param_macro_ref_builder(macro_name), internal_string_ref_builder(macro_name), param_string_getter(macro_name), internal_string_getter(macro_name), internal_macro_ref_builder(macro_name), before_first="\n", separator="\n";
        init_directives : init_directives_c(macro_name), separator="\n", before_first="\n";
        macro_builder : macro_builder(macro_name);
        empty_builder_with_context : empty_builder_with_context(macro_name);
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>
{#include<string.h>
{#include<assert.h>

{#include "Stringbuilder.h"
{#include "LinkedList.h"
{#include "Map.h"
{#include "Context.h"
{#include "InternalsInitializer.h"
{#include "InternalValue.h"
{includes}

{#include "M{macro_name}.h"

struct M{macro_name}_VT VT_M{macro_name} = {0, &HT_M{macro_name}, &M{macro_name}_build, &M{macro_name}_apply, &M{macro_name}_getChildren{function_names}};
void* HT_M{macro_name}[] = {&VT_M{macro_name}};

{constructor}

void free_M{macro_name}(M{macro_name}* this)
{
    free(this);
}


void M{macro_name}_apply(M{macro_name}* this, InternalsInitializer* visitor)
{
    exit(1);
}

LinkedList* M{macro_name}_getChildren(M{macro_name}* this)
{
    return this->children;
}

char* M{macro_name}_applyIndent(char* macro, char* indent){
    Stringbuilder *sb = new_Stringbuilder(5);
    char** lines = M{macro_name}_strSplit(macro, '\\n');

    int i;
    for (i=0; *(lines + i); i++)
    {
        if(i > 0)
        {
            sb->vt->append(sb, LINE_SEPARATOR);
        }
        sb->vt->append(sb, indent);
        sb->vt->append(sb, *(lines + i));
        free(*(lines + i));
    }

    return sb->vt->toString(sb);
}

{functions}
{init_directives}
{str_split_function}
{internal_functions}
{macro_builder}
{empty_builder_with_context}
{End}

#========== macro_builder ==========
Macro macro_builder
    Param
        context_param : context_param, before_first=", ";
        directive_calls : init_directive_call(macro_name), separator="\n";
        internal_calls : init_internals_call(macro_name), separator="\n";
        macro_body_parts : init_string_builder, string_part, param_insert_part(macro_name),  eol_part, insert_macro_part(macro_name), add_indent(macro_name), indent_part(macro_name), separator="\n";
        hidden : String;
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build{hidden}(M{macro_name}* this{context_param})
{
    LinkedList *indentations = new_LinkedList();
    Stringbuilder *sbIndentation = new_Stringbuilder(5);
{Indent: "\t"}
{directive_calls}
{internal_calls}
{End}

    Stringbuilder *sb0 = new_Stringbuilder(5);

{Indent: "\t"}
{macro_body_parts}
{End}
    return sb0->vt->toString(sb0);
}
{End}

#============ empty_builder_with_context ============
Macro empty_builder_with_context
    Param
        context_param : context_param, before_first=", ";
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build(M{macro_name}* this{context_param}) {
    return M{macro_name}_buildHidden(this);
}
{End}

#============ init_directive_call ============
Macro init_directive_call
    Param
        param_name: String;
    Internal
        macro_name : String;
{Body}
M{macro_name}_init{param_name}Directives();
{End}

#============ init_internals_call ============
Macro init_internals_call
    Param
        param_name: String;
        context_arg: context_arg, none="NULL";
    Internal
        macro_name : String;
{Body}
M{macro_name}_init{param_name}Internals({context_arg});
{End}

#========== redefined_apply_initializer ==========
Macro redefined_apply_initializer
    Internal
        macro_name : String;
{Body}
void M{macro_name}_apply(M{macro_name}* this, InternalsInitializer *internalsInitializer)
{
    internalsInitializer->vt->setM{macro_name}(this);
}
{End}

#======================================================
#===================== CONSTRUCTOR ====================
#======================================================
Macro constructor_h
    Internal
        macro_name : String;
{Body}
M{macro_name}* new_M{macro_name}();
{End}

Macro constructor_c
    Param
        field_initializers : field_string_initializer, field_macro_initializer, internal_field_initializer, separator="\n";
        internal_values_initializers : init_internal_value, before_first="\n", separator="\n";
    Internal
        macro_name : String;
{Body}
M{macro_name}* new_M{macro_name}()
{
    M{macro_name}* macro = malloc(sizeof(M{macro_name}));
    macro->vt = &VT_M{macro_name};
    macro->context = new_Context();
{Indent: "\t"}
{field_initializers}
{internal_values_initializers}
{End}
    return macro;
}
{End}
#================================================================
#===================== MACRO FUNCTIONS ==========================
#================================================================
#========== param_ref_builder_h ==================
Macro param_ref_builder_h
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build{field_name}(struct M{macro_name}*);
{End}

#=========== param_string_ref_builder =============
Macro param_string_ref_builder
    Param
        field_name : String;
        context_param : context_param, before_first=", ";
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build{field_name}(M{macro_name} *this{context_param})
{
    return this->list_{field_name}->vt->toString(this->list_{field_name});
}
{End}

#========== param_macro_ref_builder ==================
Macro param_macro_ref_builder
    Param
        field_name : String;
        macro_type : String;
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build{field_name}(M{macro_name} *this)
{
    Stringbuilder *sb = new_Stringbuilder(5);
    LinkedList* macros = this->list_{field_name};
    Context *local_context = &(this->context);

    int i = 0;
    int nb_macros = macros->size;
    char* expansion = NULL;

    for(i; i < nb_macros;i++)
    {
        M{macro_type} *macro = macros->vt->getAtIndex(macros, i);
        expansion = macro->vt->build(macro, local_context);

        sb->vt->append(sb, expansion);
    }

    return sb->vt->toString(sb);
}
{End}

#=========== internal_ref_builder_h =============
Macro internal_ref_builder_h
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build{field_name}(struct M{macro_name}*, Context *context);
{End}

#=========== internal_string_ref_builder =============
Macro internal_string_ref_builder
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build{field_name}(M{macro_name} *this, Context *context)
{
    LinkedList *ll = this->vt->get{field_name}(this, context);
    if(ll != NULL)
    {
        return ll->vt->toString(ll);
    }
    return "";
}
{End}

#=========== internal_macro_ref_builder =============
Macro internal_macro_ref_builder
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build{field_name}(M{macro_name} *this, Context *context)
{
    InternalValue *internalValue = this->vt->get{field_name}(this, context);
    if(internalValue != NULL)
    {
        return internalValue->vt->build(internalValue);
    }
    return "";
}
{End}

#========= internal_macro_setter_h =========
Macro internal_macro_setter_h
    Param
        param_name : String;
    Internal
        macro_name : String;
{Body}
void M{macro_name}_set{param_name}(M{macro_name} *this, struct Context *context, struct InternalValue *internal_value);
{End}

#========= internal_macro_setter_vt_h =========
Macro internal_macro_setter_vt_h
    Param
        param_name : String;
    Internal
        macro_name : String;
{Body}
void (*set{param_name})(M{macro_name} *this, struct Context *context, struct InternalValue *internal_value);
{End}

#========= internal_macro_setter =========
Macro internal_macro_setter
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
void M{macro_name}_set{field_name}(M{macro_name} *this, Context *context, InternalValue *internal_value) {
    if(internal_value == NULL){
        exit(1);
    }

    map_set(&(this->list_{field_name}), context, internal_value);
}
{End}

#=========== param_string_getter =============
Macro param_string_getter
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_get{field_name}(M{macro_name} *this)
{
    return this->list_{field_name}->vt->toString(this->list_{field_name});
}
{End}

#========= internal_string_setter_h =========
Macro internal_string_setter_h
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
void M{macro_name}_set{field_name}(struct M{macro_name}*, Context *key,void* value);
{End}

#========= internal_string_setter_vt_h =========
Macro internal_string_setter_vt_h
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
void (*set{field_name})(struct M{macro_name}*, Context *key,void* value);
{End}

#========= internal_string_setter =========
Macro internal_string_setter
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
void M{macro_name}_set{field_name}(M{macro_name} *this, Context *key,void* value)
{
    map_set(&this->list_{field_name}, key, value);
}
{End}

#========= internal_string_getter_h =========
Macro internal_string_getter_h
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
void* M{macro_name}_get{field_name}(M{macro_name} *this, Context *key);
{End}

#========= internal_string_getter_vt_h =========
Macro internal_string_getter_vt_h
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
void* (*get{field_name})(M{macro_name} *this, Context *key);
{End}

#========= internal_string_getter =========
Macro internal_string_getter
    Param
        field_name : String;
    Internal
        macro_name : String;
{Body}
void* M{macro_name}_get{field_name}(M{macro_name} *this, Context *key)
{
    char* value = map_get(&this->list_{field_name}, key);
    return value;
}
{End}

#=========== init_directives_h ===========
Macro init_directives_h
    Param
        param_name : String;
    Internal
        macro_name : String;
{Body}
void M{macro_name}_init{param_name}Directives(struct M{macro_name}*);
{End}

#=========== init_directives_c ===========
Macro init_directives_c
    Param
        param_name : String;
        new_directive : new_directive(macro_name, param_name), separator="\n";
    Internal
        macro_name : String;
{Body}
void M{macro_name}_init{param_name}Directives(M{macro_name} *this){
{Indent: "\t"}
{new_directive}
{End}
}
{End}

#=========== new_directives ===========
Macro new_directive
    Param
        directive_name : String;
        index_builder : String;
        macro_body_parts : string_part, param_insert_part(macro_name), eol_part, insert_macro_part(macro_name);
    Internal
        macro_name : String;
        param_name : String;
{Body}
Stringbuilder *sb{index_builder} = new_Stringbuilder(5);
{macro_body_parts}
this->{param_name}{directive_name} = new_D{directive_name}(sb{index_builder}->vt->toString());
this->{param_name}Value->vt->set{directive_name}(this->{param_name}{directive_name});
{End}

#============================
#========== Fields    =======
#============================

#========== field_string_declaration ==========
Macro field_string_declaration
    Param
        field_name : String;
{Body}
struct LinkedList *list_{field_name};
{End}

#========== field_string_initializer ==========
Macro field_string_initializer
    Param
        field_name : String;
{Body}
macro->list_{field_name} = new_LinkedList();
{End}

#========== field_macro_declaration ==========
Macro field_macro_declaration
    Param
        field_name : String;
{Body}
struct LinkedList *list_{field_name};
{End}

#========== field_macro_initializer ==========
Macro field_macro_initializer
    Param
        field_name : String;
{Body}
macro->list_{field_name} = new_LinkedList();
{End}

#========== internal_field_declaration ==========
Macro internal_field_declaration
    Param
        field_name : String;
{Body}
map_void_t list_{field_name};
{End}

#========== internal_field_initializer ==========
Macro internal_field_initializer
    Param
        field_name : String;
{Body}
map_init(&macro->list_{field_name});
{End}

#========== internal_field_deinitializer ==========
Macro internal_field_deinitializer
    Param
        field_name : String;
{Body}
map_deinit(&macro->list_{field_name});
{End}

#========== context_field =========
Macro context_field
    Param
        name : String;
{Body}
struct Context {name}Context = new_Context();
{End}

#========== directive_fields_declaration ==========
Macro directive_fields_declaration
    Param
        field_name : String;
{Body}
DSeparator *{field_name}Separator;

DBeforeFirst *{field_name}BeforeFirst;

DAfterLast *{field_name}AfterLast;

DNone *{field_name}None;
{End}

# =========== internal_macros_value_field ========
Macro internal_macros_value_field
    Param
        param_name: String;
{Body}
struct InternalValue *{param_name}Value;
{End}

#========== init_internal_value ==========
Macro init_internal_value
    Param
        param_name: String;
{Body}
this->{param_name}Value = new_InternalValue(this->list_{param_name}, this->{param_name}Context);
{End}

#============================
#========== Getter =======
#============================

#========== getter_string_vt_h ==========
Macro getter_string_vt_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
LinkedList* (*get{field_name})(struct M{class_name}*);
{End}

#========== getter_string_h ==========
Macro getter_string_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
LinkedList* M{class_name}_get{field_name}(struct M{class_name}*);
{End}

#========== getter_string_c ==========
Macro getter_string_c
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
LinkedList* M{class_name}_get{field_name}(struct M{class_name} *this)
{
    return this->{field_name};
}
{End}

#========== getter_macro_vt_h ==========
Macro getter_macro_vt_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* (*get{field_name})(struct M{class_name}*);
{End}

#========== getter_macro_h ==========
Macro getter_macro_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* M{class_name}_get{field_name}(struct M{class_name}*);
{End}

#========== getter_macro_c ==========
Macro getter_macro_c
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* M{class_name}_get{field_name}(struct M{class_name} *this)
{
    return this->{field_name};
}
{End}

#============================
#========== Add   ===========
#============================

#========== add_string_vt_h ==========
Macro add_string_vt_h
    Param
        field_name : String;
        param_arg : param_string_arg, before_first=", ",separator=", ";
    Internal
        class_name : String;
{Body}
void (*add{field_name})(struct M{class_name}*{param_arg});
{End}

#========== add_string_h ==========
Macro add_string_h
    Param
        field_name : String;
        param_arg : param_string_arg, before_first=", ",separator=", ";
    Internal
        class_name : String;
{Body}
void M{class_name}_add{field_name}(struct M{class_name}*{param_arg});
{End}

#========== add_string_c ==========
Macro add_string_c
    Param
        field_name : String;
        param_arg : param_string_arg, before_first=", ",separator=", ";
        param_value : param_arg_name;
    Internal
        class_name : String;
{Body}
void M{class_name}_add{field_name}(struct M{class_name} *this{param_arg})
{
    this->list_{field_name}->vt->addLast(this->list_{field_name}, {param_value}, sizeof({param_value}));
}
{End}

#========= add_macro_vt_h ===========
Macro add_macro_vt_h
    Param
        field_name : String;
        param_args : param_macro_arg_h, before_first=", ",separator=", ";
    Internal
        class_name : String;
{Body}
void (*add{field_name})(struct M{class_name}*{param_args});
{End}

#========= add_macro_h ===========
Macro add_macro_h
    Param
        field_name : String;
        param_args : param_macro_arg_h, before_first=", ",separator=", ";
    Internal
        class_name : String;
{Body}
void M{class_name}_add{field_name}(struct M{class_name}*{param_args});
{End}

#========= add_macro_c ===========
Macro add_macro_c
    Param
        field_name : String;
        param_arg : param_macro_arg_c, before_first=", ",separator=", ";
    Internal
        class_name : String;
{Body}
void M{class_name}_add{field_name}(struct M{class_name}* this{param_arg}){
    if(macro == NULL){
        exit(1);
    }

    this->list_{field_name}->vt->addLast(this->list_{field_name}, {Insert: param_macro_arg_name}, sizeof({Insert: param_macro_arg_name}));
    //this->children->vt->addLast(this->children, macro, sizeof(macro));
    //Macro.cycleDetector.detectCycle(this, macro);
}
{End}

#============================
#========== Functions =======
#============================

Macro function_refs
    Param
        function_type : String;
        function_name : String;
    Internal
        macro_name : String;

{Body}
&M{macro_name}_{function_type}{function_name}
{End}

#============================
#========== Parts     =======
#============================

#========= string_part =================
Macro string_part
    Param
        string : String;
        index_builder : String;
{Body}
sb{index_builder}->vt->append(sb{index_builder}, "{string}");
{End}

#========= eol_part ===================
Macro eol_part
    Param
        index_builder : String;
{Body}
sb{index_builder}->vt->append(sb{index_builder}, "\\n");
{End}

#========== param_insert_part ==========
Macro param_insert_part
    Param
        param_name : String;
        index_builder : String;
        context_arg : context_arg, before_first=", ";
    Internal
        macro_name : String;
{Body}
sb{index_builder}->vt->append(sb{index_builder}, M{macro_name}_build{param_name}(this{context_arg}));
{End}

#========== indent_part ===========
Macro indent_part
    Param
        index_builder : String;
        index_indent : String;
    Internal
        macro_name : String;
{Body}
sb{index_builder}->vt->append(sb{index_builder}, M{macro_name}_applyIndent(sb{index_indent}->vt->toString(sb{index_indent}), indentations->vt->getAtIndex(indentations, indentations->size-1)));
indentations->vt->removeLast(indentations);
{End}

#========== insert_macro_part ===============
Macro insert_macro_part
    Param
        index_builder : String;
        index_insert : String;
        macro_body_parts : init_string_builder, string_part, param_insert_part(macro_name), eol_part, insert_macro_part(macro_name);
        set_internals : set_internal(macro_insert_name, index_insert);
        macro_insert_name : String;
    Internal
        macro_name : String;
{Body}
M{macro_insert_name} *m{macro_insert_name}_{index_insert} = new_M{macro_insert_name}();
{macro_body_parts}
{set_internals}
sb{index_builder}->vt->append(sb{index_builder}, m{macro_insert_name}_{index_insert}->vt->build(m{macro_insert_name}_{index_insert}, NULL));
{End}

#========= init_string_builder =========
Macro init_string_builder
    Param
        index_builder : String;
{Body}
Stringbuilder *sb{index_builder} = new_Stringbuilder(5);
{End}

#========== set_internal ==================
Macro set_internal
    Param
        param_name : String;
        context : String;
        set_params : param_ref, string_builder_build;
    Internal
        macro_name : String;
        index_insert : String;
{Body}
m{macro_name}_{index_insert}->vt->set{param_name}(m{macro_name}_{index_insert}, {context}, {set_params});
{End}

#========== string_builder_build ==========
Macro string_builder_build
    Param
        index_builder : String;
{Body}
sb{index_builder}->vt->toString()
{End}

#=========== param_ref ===========
Macro param_ref
    Param
        name : String;
        get_params : context_arg, context_name, before_first=", ";
        param_name : String;
{Body}
{param_name}->vt->get{name}({param_name}{get_params})
{End}

#========== param_macro_ref_vt_h ==============
Macro param_macro_ref_vt_h
    Param
        name : String;
    Internal
        macro_name : String;
{Body}
struct InternalValue* (*get{name})(M{macro_name} *this);
{End}

#========== param_macro_ref_h ==============
Macro param_macro_ref_h
    Param
        name : String;
    Internal
        macro_name : String;
{Body}
struct InternalValue* M{macro_name}_get{name}(M{macro_name} *this);
{End}

#========== param_macro_ref_c ==============
Macro param_macro_ref_c
    Param
        name : String;
    Internal
        macro_name : String;
{Body}
InternalValue* M{macro_name}_get{name}(M{macro_name} *this){
    return this->{name}Value;
}
{End}

#========== internal_macro_ref_h ==============
Macro internal_macro_ref_h
    Param
        name : String;
    Internal
        macro_name : String;
{Body}
struct InternalValue* M{macro_name}_get{name}(M{macro_name} *this, Context *context);
{End}

#========== internal_macro_ref_vt_h ==============
Macro internal_macro_ref_vt_h
    Param
        name : String;
    Internal
        macro_name : String;
{Body}
struct InternalValue* (*get{name})(M{macro_name} *this, Context *context);
{End}

#========== internal_macro_ref_c ===========
Macro internal_macro_ref_c
    Param
        param_name: String;
    Internal
        macro_name : String;
{Body}
InternalValue* M{macro_name}_get{param_name}(M{macro_name} *this, Context *context){
    return map_get(&(this->list_{param_name}), context);
}
{End}

#========= add_indent ===================
Macro add_indent
    Param
        macro_body_parts : init_string_builder, string_part, param_insert_part(macro_name), eol_part, insert_macro_part(macro_name);
    Internal
        macro_name : String;
{Body}
sbIndentation = new_Stringbuilder(5);
{macro_body_parts}
indentations->vt->addLast(indentations, sbIndentation->vt->toString(sbIndentation), sizeof(sbIndentation->vt->toString(sbIndentation)));
{End}

#===================================================
#===================== DIRECTIVES ==================
#===================================================
#=========== class_none_h ============
Macro class_none_h
{Body}
{Insert: header}

{#ifndef DNONE_H
{#define DNONE_H

extern struct DNone_VT VT_DNone;
extern void *HT_DNone;

typedef struct DNone
{
    struct DNone_VT (*vt);
    char* value;
} DNone;

typedef struct DNone_VT
{
    int hl;
    void* (*ht)[];
    char* (*apply)(int index, char* macro, int list_size);
} DNone_VT;

DNone* new_DNone(char* value);
void free_DNone(struct DNone*);

char* DNone_apply(int index, char* macro, int list_size);

{#endif //DNONE_H
{End}

#=========== class_none_c ============
Macro class_none_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "DNone.h"

struct DNone_VT VT_DNone = {1, &HT_DNone, &DNone_apply};
void* HT_DNone[] = {&VT_DNone};

DNone* new_DNone(char* value)
{
    DNone* none = malloc(sizeof(DNone));
    none->vt = &VT_DNone;
    none->value = value;
    return none;
}

void free_DNone(DNone* this)
{
    free(this);
}

char* DNone_apply(DNone *this, int index, char* macro, int list_size)
{
    if(list_size == 0){
        return this->value;
    }

    return macro;
}
{End}

#========== class_before_first_h =========
Macro class_before_first_h
{Body}
{Insert: header}

{#ifndef DBEFOREFIRST_H
{#define DBEFOREFIRST_H

extern struct DBeforeFirst_VT VT_DBeforeFirst;
extern void *HT_DBeforeFirst;

typedef struct DBeforeFirst
{
    struct DBeforeFirst_VT (*vt);
    char* value;
} DBeforeFirst;

typedef struct DBeforeFirst_VT
{
    int hl;
    void* (*ht)[];
    char* (*apply)(int index, char* macro, int list_size);
} DBeforeFirst_VT;

DBeforeFirst* new_DBeforeFirst(char* value);
void free_DBeforeFirst(struct DBeforeFirst*);

char* DBeforeFirst_apply(int index, char* macro, int list_size);

{#endif //DBEFOREFIRST_H
{End}

#=========== class_before_first_c ============
Macro class_before_first_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "DBeforeFirst.h"

struct DBeforeFirst_VT VT_DBeforeFirst = {1, &HT_DBeforeFirst, &DBeforeFirst_apply};
void* HT_DBeforeFirst[] = {&VT_DBeforeFirst};

DBeforeFirst* new_DBeforeFirst(char* value)
{
    DBeforeFirst* beforeFirst = malloc(sizeof(DBeforeFirst));
    beforeFirst->vt = &VT_DBeforeFirst;
    beforeFirst->value = value;
    return beforeFirst;
}

void free_DBeforeFirst(DBeforeFirst* this)
{
    free(this);
}

char* DBeforeFirst_apply(DBeforeFirst *this, int index, char* macro, int list_size)
{
    if(index == 0){
        strcpy(this->value, macro);
        return this->value;
    }
    return macro;
}
{End}

#========== class_after_last_h ==========
Macro class_after_last_h
{Body}
{Insert: header}

{#ifndef DAFTERLAST_H
{#define DAFTERLAST_H

extern struct DAfterLast_VT VT_DAfterLast;
extern void *HT_DAfterLast;

typedef struct DAfterLast
{
    struct DAfterLast_VT (*vt);
    char* value;
} DAfterLast;

typedef struct DAfterLast_VT
{
    int hl;
    void* (*ht)[];
    char* (*apply)(int index, char* macro, int list_size);
} DAfterLast_VT;

DAfterLast* new_DAfterLast(char* value);
void free_DAfterLast(struct DAfterLast*);

char* DAfterLast_apply(int index, char* macro, int list_size);

{#endif //DAFTERLAST_H
{End}

#=========== class_after_last_c ============
Macro class_after_last_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "DAfterLast.h"

struct DAfterLast_VT VT_DAfterLast = {1, &HT_DAfterLast, &DAfterLast_apply};
void* HT_DAfterLast[] = {&VT_DAfterLast};

DAfterLast* new_DAfterLast(char* value)
{
    DAfterLast* afterLast = malloc(sizeof(DAfterLast));
    afterLast->vt = &VT_DAfterLast;
    afterLast->value = value;
    return afterLast;
}

void free_DAfterLast(DAfterLast* this)
{
    free(this);
}

char* DAfterLast_apply(DAfterLast *this, int index, char* macro, int list_size)
{
    if(index == list_size - 1){
        strcpy(this->value, macro);
        return this->value;
    }
    return macro;
}
{End}

#======== class_separator_h ===========
Macro class_separator_h
{Body}
{Insert: header}

{#ifndef DSEPARATOR_H
{#define DSEPARATOR_H

extern struct DSeparator_VT VT_DSeparator;
extern void *HT_DSeparator;

typedef struct DSeparator
{
    struct DSeparator_VT (*vt);
    char* value;
} DSeparator;

typedef struct DSeparator_VT
{
    int hl;
    void* (*ht)[];
    char* (*apply)(int index, char* macro, int list_size);
} DSeparator_VT;

DSeparator* new_DSeparator(char* value);
void free_DSeparator(struct DSeparator*);

char* DSeparator_apply(int index, char* macro, int list_size);

{#endif //DSEPARATOR_H
{End}

#=========== class_separator_c ============
Macro class_separator_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "DSeparator.h"

struct DSeparator_VT VT_DSeparator = {1, &HT_DSeparator, &DSeparator_apply};
void* HT_DSeparator[] = {&VT_DSeparator};

DSeparator* new_DSeparator(char* value)
{
    DSeparator* separator = malloc(sizeof(DSeparator));
    separator->vt = &VT_DSeparator;
    separator->value = value;
    return separator;
}

void free_DSeparator(DSeparator* this)
{
    free(this);
}

char* DSeparator_apply(DSeparator *this, int index, char* macro, int list_size)
{
    if(index == list_size - 1){
        return macro;
    }
    strcpy(this->value, macro);
    return this->value;
}
{End}

#===================================================
#===================== OTHER =======================
#===================================================

#========== string_value ========
Macro string_value
  Param
    string : String;
{Body}
"{string}"
{End}

#=========== macro_arg ==========
Macro macro_arg
  Param
    name : String;
{Body}
list_{name}
{End}

#=========== string_arg =========
Macro string_arg
  Param
    name : String;
{Body}
list_{name}
{End}

#========== param_macro_arg_type ==========
Macro param_macro_arg_type
  Param
    name : String;
{Body}
M{name}
{End}

#========== param_arg_type ==========
Macro param_arg_type
  Param
    name : String;
{Body}
{name}
{End}

#========== param_arg_name ==========
Macro param_arg_name
  Param
    name : String;
{Body}
p{name}
{End}

#========== param_macro_arg_name ==========
Macro param_macro_arg_name
{Body}
macro
{End}

#========== param_macro_arg_h ==========
Macro param_macro_arg_h
    Param
        param_type : param_macro_arg_type;
{Body}
struct {param_type}*
{End}

#========== param_macro_arg_c ==========
Macro param_macro_arg_c
    Param
        param_type : param_macro_arg_type, before_first="struct ";
{Body}
{param_type} *{Insert: param_macro_arg_name}
{End}

#========== param_string_arg ==========
Macro param_string_arg
    Param
        param_type : param_arg_type;
        param_arg : param_arg_name;
{Body}
{param_type} {param_arg}
{End}

#=========== context_name =============
Macro context_name
  Param
    context_name : String;
{Body}
{context_name}
{End}

#======== context_param ============
Macro context_param
{Body}
Context *context
{End}

#========= context_arg ============
Macro context_arg
{Body}
context
{End}

#=========== get_internal_tail ============
Macro get_internal_tail
{Body}
->vt->get(context)
{End}

#========== string_param ==========
Macro string_param
  Param
    name : String;
{Body}
char* p{name}
{End}