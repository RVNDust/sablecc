#This file is part of SableCC ( http://sablecc.org ).
#
#See the NOTICE file distributed with this work for copyright information.
#
#Licensed under the Apache License, Version 2.0 (the "License");
#you may not use this file except in compliance with the License.
#You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#Unless required by applicable law or agreed to in writing, software
#distributed under the License is distributed on an "AS IS" BASIS,
#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#See the License for the specific language governing permissions and
#limitations under the License.

#============================
#========== Utils  ==========
#============================

#========== header ==========
Macro header
{Body}
/* This file was generated by SableCC's ObjectMacro. */
{End}

#========== include ==========
Macro include
    Param
        include_name : String;
{Body}
include "{include_name}.h"
{End}

#========== linked_list_node_h ==========
Macro linked_list_node_h
{Body}
{Insert: header}

{#ifndef LINKEDLISTNODE_H
{#define LINKEDLISTNODE_H

typedef struct Node
{
    void *data;
    struct Node *next;
} Node;

Node* new_Node();
void free_Node(struct Node*);

{#endif //LINKEDLISTNODE_H
{End}

#========== linked_list_node_c ==========
Macro linked_list_node_c
{Body}
{Insert: header}

{#include <stdio.h>
{#include <stdlib.h>

{#include "LinkedListNode.h"

Node* new_Node()
{
    Node* node = malloc(sizeof(Node));
    node->data = NULL;
    node->next = NULL;
    return node;
}

void free_Node(Node* This)
{
    This->data = NULL;
    This->next = NULL;
    free(This);
}
{End}

#========== linked_list_h ==========
Macro linked_list_h
{Body}
{Insert: header}

{#ifndef LINKEDLIST_H
{#define LINKEDLIST_H

extern struct LinkedList_VT VT_LinkedList;
extern void *HT_LinkedList[];

typedef struct LinkedList
{
    struct LinkedListVT (*vt);
    struct Node *nodes;
    unsigned int size;
} LinkedList;

typedef struct LinkedList_VT
{
    int hl;
    void* (*ht)[];
    void (*addFirst)(struct LinkedList*, void *new_data, size_t data_size);
    void (*addLast)(struct LinkedList*, void *new_data, size_t data_size);
    void (*addAtIndex)(struct LinkedList*, void *new_data, size_t data_size, unsigned int index);
    void (*removeFirst)(struct LinkedList*);
    void (*removeLast)(struct LinkedList*);
    void (*removeAtIndex)(struct LinkedList*, unsigned int index);
    char* (*toString)(struct LinkedList*);
} LinkedList_VT;

LinkedList* new_LinkedList();
void free_LinkedList(struct LinkedList*);

void LinkedList_addFirst(struct LinkedList*, void *new_data, size_t data_size);
void LinkedList_addLast(struct LinkedList*, void *new_data, size_t data_size);
void LinkedList_addAtIndex(struct LinkedList*, void *new_data, size_t data_size, unsigned int index);
void LinkedList_removeFirst(struct LinkedList*);
void LinkedList_removeLast(struct LinkedList*);
void LinkedList_removeAtIndex(struct LinkedList*, unsigned int index);
char* LinkedList_toString(struct LinkedList*);

{#endif //LINKEDLIST_H
{End}

#========== linked_list_c ==========
Macro linked_list_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>
{#include<string.h>

{#include "LinkedListNode.h"
{#include "LinkedList.h"

struct LinkedList_VT VT_LinkedList={0, &HT_LinkedList, &LinkedList_addFirst, &LinkedList_addLast, &LinkedList_addAtIndex, &LinkedList_removeFirst, &LinkedList_removeLast, &LinkedList_removeAtIndex, &LinkedList_toString};
void* HT_LinkedList[] = {&VT_LinkedList};

LinkedList* new_LinkedList()
{
    LinkedList* linkedList = malloc(sizeof(LinkedList));
    linkedList->vt = &VT_LinkedList;
    linkedList->nodes = NULL;
    linkedList->size = 0;
    return linkedList;
}

void free_LinkedList(LinkedList* This)
{
    //TODO
}

void LinkedList_addFirst(LinkedList* This, void *new_data, size_t data_size)
{
    This->vt->addAtIndex(This, new_data, data_size, 0);
}

void LinkedList_addLast(LinkedList* This, void *new_data, size_t data_size)
{
    This->vt->addAtIndex(This, new_data, data_size, This->size-1);
}

void LinkedList_addAtIndex(LinkedList* This, void *new_data, size_t data_size, unsigned int index)
{
    if(index <= This->size)
    {
        struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
        new_node->data = malloc(data_size);
        new_node->data = new_data;

        if(This->nodes != NULL)
        {
            Node* prevNode = NULL;
            Node* currentNode = This->nodes;

            if(index==0)
            {
                new_node->next = currentNode;
                This->nodes = new_node;
            }
            else
            {
                for(int i = 0; i < index; i++)
                {
                    prevNode = currentNode;
                    currentNode = currentNode->next;
                }

                prevNode->next = new_node;
                new_node->next = currentNode;
            }
        }
        else
        {
            This->nodes = new_node;
        }

        This->size = This->size + 1;
    }
    else
    {
        exit(1);
    }
}

void LinkedList_removeFirst(LinkedList* This)
{
    This->vt->removeAtIndex(This, 0);
}

void LinkedList_removeLast(LinkedList* This)
{
    This->vt->removeAtIndex(This, This->size-1);
}

void LinkedList_removeAtIndex(LinkedList* This, unsigned int index)
{
    if(index <= This->size)
    {
        if(This->nodes != NULL)
        {
            Node* prevNode = NULL;
            Node* currentNode = This->nodes;
            if(This->size == 1)
            {
                This->nodes = NULL;
            }
            else
            {
                for(int i = 0; i < index; i++)
                {
                    prevNode = currentNode;
                    currentNode = currentNode->next;
                }

                prevNode->next = currentNode->next;
            }
            free_Node(currentNode);
            This->size = This->size - 1;
        }
    }
    else
    {
        exit(1);
    }
}

char* LinkedList_toString(LinkedList* This)
{
    Node *currentNode = This->nodes;
    int currentTextSize = 1;

    if(currentNode != NULL)
    {
        void *current_data = NULL;
        for(int i = 0; i < This->size; i++)
        {
            current_data = currentNode->data;
            //int textSize = strlen((char*)current_data);
            //int textSize = sizeof(current_data);
            currentTextSize = currentTextSize + textSize;

            currentNode = currentNode->next;
        }

        char *currentText = calloc(currentTextSize, sizeof(char));
        strcpy(currentText, "");
        //char *currentText = "";

        currentNode = This->nodes;

        for(int i = 0; i < This->size; i++)
        {
            current_data = currentNode->data;
            strcat(currentText, (const char*)current_data);
            currentNode = currentNode->next;
        }

        return currentText;
    }

    return "";
}

{End}

#========== string_builder_h ==========
Macro string_builder_h
{Body}
{Insert: header}

{#ifndef STRINGBUILDER_H
{#define STRINGBUILDER_H

{#include <stddef.h>
{#include <stdbool.h>

extern struct Stringbuilder_VT VT_Stringbuilder;
extern void *HT_Stringbuilder[];

typedef struct Stringbuilder
{
    struct Stringbuilder_VT (*vt);
    char* mem;
    size_t count;
    size_t cap;
} Stringbuilder;

typedef struct Stringbuilder_VT
{
    int hl;
    void* (*ht)[];
    bool (*append)(struct Stringbuilder*, char*);
    char* (*toString)(struct Stringbuilder*);
} Stringbuilder_VT;

Stringbuilder* new_Stringbuilder(size_t init_cap);
void free_Stringbuilder(struct Stringbuilder*);

bool Stringbuilder_append(struct Stringbuilder*, char*);
char* Stringbuilder_toString(struct Stringbuilder*);

{#endif //STRINGBUILDER_H
{End}


#========== string_builder_c ==========
Macro string_builder_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "Stringbuilder.h"

struct Stringbuilder_VT VT_Stringbuilder={0, &HT_Stringbuilder, &Stringbuilder_append, &Stringbuilder_toString};
void* HT_Stringbuilder[] = {&VT_Stringbuilder};

Stringbuilder* new_Stringbuilder(size_t init_cap)
{
    Stringbuilder* ret = malloc(sizeof(struct Stringbuilder));
    if (!ret) return NULL;
    ret->mem = calloc(init_cap, sizeof(char));
    if (!ret->mem) return NULL;
    ret->cap = init_cap;
    ret->count = 0;
    return ret;
}

void free_Stringbuilder(Stringbuilder* This)
{
    free(sb->mem);
    free(sb);
}

{#define LOAD_FACTOR 2
bool Stringbuilder_append(Stringbuilder *This, char* string)
{
    bool size_ok = true;
    int len = strlen(string);
    for(int i = 0; i < len; i++)
    {
        size_ok = Stringbuilder_appendChar(to, string[i]);
    }
    return size_ok;
}

bool Stringbuilder_appendChar(Stringbuilder *This, char c) {
    This->mem[This->count] = c;
    ++This->count;
    if (This->count == This->cap) {
        char *new_mem = realloc(This->mem, This->cap * LOAD_FACTOR);
        if (!new_mem) {
            return false;
        }
        memset(new_mem + This->cap, 0, This->cap);
        This->mem = new_mem;
        This->cap *= LOAD_FACTOR;
    }
    return true;
}

char* Stringbuilder_toString(Stringbuilder *This) {
    return This->mem;
}
{End}

#============================
#========== Basics   ========
#============================

#========== super_macro_h ==========
Macro super_macro_h
{Body}
{Insert: header}

{#ifndef MACRO_H
{#define MACRO_H

extern struct Macro_VT VT_Macro;
extern void *HT_Macro[];
extern char* LINE_SEPARATOR = "";

typedef struct Macro
{
    struct Macro_VT (*vt);
} Macro;

typedef struct Macro_VT
{
    int hl;
    void* (*ht)[];
    char* (*build)(struct Macro*);
    void (*apply)(struct Macro*);
} Macro_VT;

Macro* new_Macro();
void free_Macro(Macro*);

char* Macro_build(struct Macro*);
void Macro_apply(struct Macro*);

{#endif //MACRO_H
{End}

#========== super_macro_c ==========
Macro super_macro_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "Macro.h"

struct Macro_VT VT_Macro = {0, &HT_Macro, &Macro_build, &Macro_apply};
void* HT_Macro[] = {&VT_Macro};

Macro* new_Macro()
{
    Macro* macro = malloc(sizeof(Macro));
    macro->vt = &VT_Macro;
    return macro;
}

void free_Macro(Macro* This)
{
    free(This);
}

char* Macro_build(Macro* This)
{
    exit(1);
}

void Macro_apply(Macro* This)
{
    exit(1);
}
{End}

#========== macro_h ==========
Macro macro_h
    Param
        macro_name : String;
        fields : field_string_declaration, separator="\n";
        methods : getter_string_vt_h(macro_name), setter_string_vt_h(macro_name), separator="\n";
        functions : getter_string_h(macro_name), setter_string_h(macro_name), separator="\n";
{Body}
{#ifndef {macro_name}_H
{#define {macro_name}_H

extern struct {macro_name}_VT VT_{macro_name};
extern void *HT_{macro_name};

typedef struct {macro_name}
{
    struct {macro_name}_VT (*vt);
{Indent: "\t"}
{fields}
{End}
} {macro_name};

typedef struct {macro_name}_VT
{
    int hl;
    void* (*ht)[];
{Indent: "\t"}
{methods}
{End}
}

{macro_name}* new_{macro_name}();
void free_{macro_name}(struct {macro_name}*);
char* {macro_name}_build({macro_name}* This);
void {macro_name}_apply({macro_name}* This);

{functions}

{#endif {macro_name}_H
{End}

#========== macro_c ==========
Macro macro_c
    Param
        macro_name : String;
        field_initializers : field_string_initializer(macro_name), separator="\n";
        function_names :  function_refs(macro_name) ,before_first=" ,", separator=" ,";
        functions : getter_string_c(macro_name), setter_string_c(macro_name), separator="\n";
        macro_builder : macro_builder(macro_name);
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "Macro.h"
{#include "{macro_name}.h"

struct {macro_name}_VT VT_{macro_name} = {0, &HT_{macro_name}, &{macro_name}_build, &{macro_name}_apply{function_names}};
void* HT_{macro_name}[] = {&VT_{macro_name}};

{macro_name}* new_{macro_name}()
{
    {macro_name}* macro = malloc(sizeof({macro_name}));
    macro->vt = &VT_{macro_name};
{Indent: "\t"}
{field_initializers}
{End}
    return macro;
}

void free_{macro_name}({macro_name}* This)
{
    free(This);
}

{macro_builder}

void {macro_name}_apply({macro_name}* This)
{
    exit(1);
}

{functions}
{End}

Macro macro_builder
    Param
        macro_body_parts : string_part, separator="\n";
    Internal
        macro_name : String;
{Body}
char* {macro_name}_build({macro_name}* This)
{
    Stringbuilder sb0 = new_Stringbuilder(5);
{Indent: "\t"}
{macro_body_parts}
{End}
    return sb0->vt->toString();
}
{End}

#============================
#========== Fields    =======
#============================

#========== field_string_declaration ==========
Macro field_string_declaration
    Param
        field_name : String;
{Body}
char* {field_name};
{End}

#========== field_string_initializer ==========
Macro field_string_initializer
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
{class_name}->{field_name} = "";
{End}

#============================
#========== Getter =======
#============================

#========== getter_string_vt_h ==========
Macro getter_string_vt_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* (*get{field_name})(struct {class_name}*);
{End}

#========== getter_string_h ==========
Macro getter_string_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* {class_name}_get{field_name}(struct {class_name}*);
{End}

#========== getter_string_c ==========
Macro getter_string_c
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* {class_name}_get{field_name}(struct {class_name} *This)
{
    return This->{field_name};
}
{End}

#============================
#========== Setter =======
#============================

#========== setter_string_vt_h ==========
Macro setter_string_vt_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
void (*set{field_name})(struct {class_name}*, char* value);
{End}

#========== setter_string_h ==========
Macro setter_string_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
void {class_name}_set{field_name}(struct {class_name}*, char* value);
{End}

#========== setter_string_c ==========
Macro setter_string_c
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
void {class_name}_set{field_name}(struct {class_name} *This, char* value)
{
    This->{field_name} = value;
}
{End}

#============================
#========== Function =======
#============================

Macro function_refs
    Param
        function_type : String;
        function_name : String;
    Internal
        macro_name : String;

{Body}
&{macro_name}_{function_type}{function_name}
{End}

#============================
#========== Parts     =======
#============================

Macro string_part
    Param
        string : String;
        index_builder : String;
{Body}
sb{index_builder}->vt->append("{string}");
{End}