#This file is part of SableCC ( http://sablecc.org ).
#
#See the NOTICE file distributed with this work for copyright information.
#
#Licensed under the Apache License, Version 2.0 (the "License");
#you may not use this file except in compliance with the License.
#You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#Unless required by applicable law or agreed to in writing, software
#distributed under the License is distributed on an "AS IS" BASIS,
#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#See the License for the specific language governing permissions and
#limitations under the License.

#============================
#========== Utils  ==========
#============================

#========== header ==========
Macro header
{Body}
/* This file was generated by SableCC's ObjectMacro. */
{End}

#========== include ==========
Macro include
    Param
        include_name : String;
{Body}
include "{include_name}.h"
{End}

#========== linked_list_node_h ==========
Macro linked_list_node_h
{Body}
{Insert: header}

{#ifndef LINKEDLISTNODE_H
{#define LINKEDLISTNODE_H

typedef struct Node
{
    void *data;
    struct Node *next;
} Node;

Node* new_Node();
void free_Node(struct Node*);

{#endif //LINKEDLISTNODE_H
{End}

#========== linked_list_node_c ==========
Macro linked_list_node_c
{Body}
{Insert: header}

{#include <stdio.h>
{#include <stdlib.h>

{#include "LinkedListNode.h"

Node* new_Node()
{
    Node* node = malloc(sizeof(Node));
    node->data = NULL;
    node->next = NULL;
    return node;
}

void free_Node(Node* This)
{
    This->data = NULL;
    This->next = NULL;
    free(This);
}
{End}

#========== linked_list_h ==========
Macro linked_list_h
{Body}
{Insert: header}

{#ifndef LINKEDLIST_H
{#define LINKEDLIST_H

extern struct LinkedList_VT VT_LinkedList;
extern void *HT_LinkedList[];

typedef struct LinkedList
{
    struct LinkedListVT (*vt);
    struct Node *nodes;
    unsigned int size;
} LinkedList;

typedef struct LinkedList_VT
{
    int hl;
    void* (*ht)[];
    void (*addFirst)(struct LinkedList*, void *new_data, size_t data_size);
    void (*addLast)(struct LinkedList*, void *new_data, size_t data_size);
    void (*addAtIndex)(struct LinkedList*, void *new_data, size_t data_size, unsigned int index);
    void (*removeFirst)(struct LinkedList*);
    void (*removeLast)(struct LinkedList*);
    void (*removeAtIndex)(struct LinkedList*, unsigned int index);
    char* (*toString)(struct LinkedList*);
} LinkedList_VT;

LinkedList* new_LinkedList();
void free_LinkedList(struct LinkedList*);

void LinkedList_addFirst(struct LinkedList*, void *new_data, size_t data_size);
void LinkedList_addLast(struct LinkedList*, void *new_data, size_t data_size);
void LinkedList_addAtIndex(struct LinkedList*, void *new_data, size_t data_size, unsigned int index);
void LinkedList_removeFirst(struct LinkedList*);
void LinkedList_removeLast(struct LinkedList*);
void LinkedList_removeAtIndex(struct LinkedList*, unsigned int index);
char* LinkedList_toString(struct LinkedList*);

{#endif //LINKEDLIST_H
{End}

#========== linked_list_c ==========
Macro linked_list_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>
{#include<string.h>

{#include "LinkedListNode.h"
{#include "LinkedList.h"

struct LinkedList_VT VT_LinkedList={0, &HT_LinkedList, &LinkedList_addFirst, &LinkedList_addLast, &LinkedList_addAtIndex, &LinkedList_removeFirst, &LinkedList_removeLast, &LinkedList_removeAtIndex, &LinkedList_toString};
void* HT_LinkedList[] = {&VT_LinkedList};

LinkedList* new_LinkedList()
{
    LinkedList* linkedList = malloc(sizeof(LinkedList));
    linkedList->vt = &VT_LinkedList;
    linkedList->nodes = NULL;
    linkedList->size = 0;
    return linkedList;
}

void free_LinkedList(LinkedList* This)
{
    //TODO
}

void LinkedList_addFirst(LinkedList* This, void *new_data, size_t data_size)
{
    This->vt->addAtIndex(This, new_data, data_size, 0);
}

void LinkedList_addLast(LinkedList* This, void *new_data, size_t data_size)
{
    This->vt->addAtIndex(This, new_data, data_size, This->size-1);
}

void LinkedList_addAtIndex(LinkedList* This, void *new_data, size_t data_size, unsigned int index)
{
    if(index <= This->size)
    {
        struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
        new_node->data = malloc(data_size);
        new_node->data = new_data;

        if(This->nodes != NULL)
        {
            Node* prevNode = NULL;
            Node* currentNode = This->nodes;

            if(index==0)
            {
                new_node->next = currentNode;
                This->nodes = new_node;
            }
            else
            {
                for(int i = 0; i < index; i++)
                {
                    prevNode = currentNode;
                    currentNode = currentNode->next;
                }

                prevNode->next = new_node;
                new_node->next = currentNode;
            }
        }
        else
        {
            This->nodes = new_node;
        }

        This->size = This->size + 1;
    }
    else
    {
        exit(1);
    }
}

void LinkedList_removeFirst(LinkedList* This)
{
    This->vt->removeAtIndex(This, 0);
}

void LinkedList_removeLast(LinkedList* This)
{
    This->vt->removeAtIndex(This, This->size-1);
}

void LinkedList_removeAtIndex(LinkedList* This, unsigned int index)
{
    if(index <= This->size)
    {
        if(This->nodes != NULL)
        {
            Node* prevNode = NULL;
            Node* currentNode = This->nodes;
            if(This->size == 1)
            {
                This->nodes = NULL;
            }
            else
            {
                for(int i = 0; i < index; i++)
                {
                    prevNode = currentNode;
                    currentNode = currentNode->next;
                }

                prevNode->next = currentNode->next;
            }
            free_Node(currentNode);
            This->size = This->size - 1;
        }
    }
    else
    {
        exit(1);
    }
}

char* LinkedList_toString(LinkedList* This)
{
    Node *currentNode = This->nodes;
    int currentTextSize = 1;

    if(currentNode != NULL)
    {
        void *current_data = NULL;
        for(int i = 0; i < This->size; i++)
        {
            current_data = currentNode->data;
            //int textSize = strlen((char*)current_data);
            //int textSize = sizeof(current_data);
            currentTextSize = currentTextSize + textSize;

            currentNode = currentNode->next;
        }

        char *currentText = calloc(currentTextSize, sizeof(char));
        strcpy(currentText, "");
        //char *currentText = "";

        currentNode = This->nodes;

        for(int i = 0; i < This->size; i++)
        {
            current_data = currentNode->data;
            strcat(currentText, (const char*)current_data);
            currentNode = currentNode->next;
        }

        return currentText;
    }

    return "";
}

{End}

#========== string_builder_h ==========
Macro string_builder_h
{Body}
{Insert: header}

{#ifndef STRINGBUILDER_H
{#define STRINGBUILDER_H

{#include <stddef.h>
{#include <stdbool.h>

extern struct Stringbuilder_VT VT_Stringbuilder;
extern void *HT_Stringbuilder[];

typedef struct Stringbuilder
{
    struct Stringbuilder_VT (*vt);
    char* mem;
    size_t count;
    size_t cap;
} Stringbuilder;

typedef struct Stringbuilder_VT
{
    int hl;
    void* (*ht)[];
    bool (*append)(struct Stringbuilder*, char*);
    char* (*toString)(struct Stringbuilder*);
} Stringbuilder_VT;

Stringbuilder* new_Stringbuilder(size_t init_cap);
void free_Stringbuilder(struct Stringbuilder*);

bool Stringbuilder_append(struct Stringbuilder*, char*);
char* Stringbuilder_toString(struct Stringbuilder*);

{#endif //STRINGBUILDER_H
{End}


#========== string_builder_c ==========
Macro string_builder_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "Stringbuilder.h"

struct Stringbuilder_VT VT_Stringbuilder={0, &HT_Stringbuilder, &Stringbuilder_append, &Stringbuilder_toString};
void* HT_Stringbuilder[] = {&VT_Stringbuilder};

Stringbuilder* new_Stringbuilder(size_t init_cap)
{
    Stringbuilder* ret = malloc(sizeof(struct Stringbuilder));
    ret->vt = &VT_Stringbuilder;
    if (!ret) return NULL;
    ret->mem = calloc(init_cap, sizeof(char));
    if (!ret->mem) return NULL;
    ret->cap = init_cap;
    ret->count = 0;
    return ret;
}

void free_Stringbuilder(Stringbuilder* This)
{
    free(sb->mem);
    free(sb);
}

{#define LOAD_FACTOR 2
bool Stringbuilder_append(Stringbuilder *This, char* string)
{
    bool size_ok = true;
    int len = strlen(string);
    for(int i = 0; i < len; i++)
    {
        size_ok = Stringbuilder_appendChar(to, string[i]);
    }
    return size_ok;
}

bool Stringbuilder_appendChar(Stringbuilder *This, char c) {
    This->mem[This->count] = c;
    ++This->count;
    if (This->count == This->cap) {
        char *new_mem = realloc(This->mem, This->cap * LOAD_FACTOR);
        if (!new_mem) {
            return false;
        }
        memset(new_mem + This->cap, 0, This->cap);
        This->mem = new_mem;
        This->cap *= LOAD_FACTOR;
    }
    return true;
}

char* Stringbuilder_toString(Stringbuilder *This) {
    return This->mem;
}
{End}

#=============== build_state_h =========
Macro build_state_h
{Body}
{Insert: header}

{#ifndef BUILDSTATE_H
{#define BUILDSTATE_H

extern struct BuildState_VT VT_BuildState;
extern void *HT_BuildState[];

typedef struct BuildState
{
    struct BuildState_VT (*vt);
    char* expansion;
} BuildState;

typedef struct BuildState_VT
{
    int hl;
    void* (*ht)[];
    char* (*getExpansion)(struct BuildState*);
    void (*setExpansion)(struct BuildState*, char* expansion);
} BuildState_VT;

BuildState* new_BuildState();
void free_BuildState();

char* BuildState_getExpansion(BuildState *This);
void BuildState_setExpansion(BuildState *This, char* expansion);

{#endif //BUILDSTATE_H
{End}

#=============== build_state_c =========
Macro build_state_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "Buildstate.h"

struct BuildState_VT VT_BuildState={0, &HT_BuildState, &BuildState_getExpansion, &BuildState_setExpansion};
void* HT_BuildState[] = {&VT_BuildState};

BuildState* new_BuildState()
{
    BuildState* buildState = malloc(sizeof(struct BuildState));
    buildState->vt = &VT_BuildState;
    buildState->expansion = NULL;
    return buildState;
}

void free_BuildState(BuildState* This)
{
    free(sb->mem);
    free(sb);
}

char* BuildState_getExpansion(BuildState *This)
{
    return This->expansion;
}

void BuildState_setExpansion(BuildState *This, char* expansion)
{
    This->expansion = expansion;
}

{End}

#============================
#========== Basics   ========
#============================

#========== super_macro_h ==========
Macro super_macro_h
{Body}
{Insert: header}

{#ifndef MACRO_H
{#define MACRO_H

extern struct Macro_VT VT_Macro;
extern void *HT_Macro[];
extern char* LINE_SEPARATOR = "";

typedef struct Macro
{
    struct Macro_VT (*vt);
} Macro;

typedef struct Macro_VT
{
    int hl;
    void* (*ht)[];
    char* (*build)(struct Macro*);
    void (*apply)(struct Macro*);
} Macro_VT;

Macro* new_Macro();
void free_Macro(Macro*);

char* Macro_build(struct Macro*);
void Macro_apply(struct Macro*);

{#endif //MACRO_H
{End}

#========== super_macro_c ==========
Macro super_macro_c
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "Macro.h"

struct Macro_VT VT_Macro = {0, &HT_Macro, &Macro_build, &Macro_apply};
void* HT_Macro[] = {&VT_Macro};

Macro* new_Macro()
{
    Macro* macro = malloc(sizeof(Macro));
    macro->vt = &VT_Macro;
    return macro;
}

void free_Macro(Macro* This)
{
    free(This);
}

char* Macro_build(Macro* This)
{
    exit(1);
}

void Macro_apply(Macro* This)
{
    exit(1);
}
{End}

#========== macro_h ==========
Macro macro_h
    Param
        macro_name : String;
        fields : field_string_declaration, field_macro_declaration, separator="\n";
        constructor : constructor_h(macro_name);
        methods : getter_string_vt_h(macro_name), setter_string_vt_h(macro_name), add_macro_vt_h(macro_name),separator="\n";
        functions : getter_string_h(macro_name), setter_string_h(macro_name), add_macro_h(macro_name), separator="\n";
{Body}
{#ifndef M{macro_name}_H
{#define M{macro_name}_H

extern struct M{macro_name}_VT VT_M{macro_name};
extern void *HT_M{macro_name};

typedef struct M{macro_name}
{
    struct M{macro_name}_VT (*vt);
{Indent: "\t"}
{fields}
{End}
} M{macro_name};

typedef struct M{macro_name}_VT
{
    int hl;
    void* (*ht)[];
{Indent: "\t"}
{methods}
{End}
}

{constructor}
void free_M{macro_name}(struct M{macro_name}*);
char* M{macro_name}_build(M{macro_name}* This);
void M{macro_name}_apply(M{macro_name}* This);

{functions}

{#endif M{macro_name}_H
{End}

#========== macro_c ==========
Macro macro_c
    Param
        macro_name : String;
        constructor : constructor_c(macro_name);
        function_names :  function_refs(macro_name) ,before_first=" ,", separator=" ,";
        functions : getter_string_c(macro_name), setter_string_c(macro_name), add_macro_c(macro_name), separator="\n";
        macro_builder : macro_builder(macro_name);
{Body}
{Insert: header}

{#include<stdlib.h>
{#include<stdio.h>

{#include "Macro.h"
{#include "M{macro_name}.h"

struct M{macro_name}_VT VT_M{macro_name} = {0, &HT_M{macro_name}, &M{macro_name}_build, &M{macro_name}_apply{function_names}};
void* HT_M{macro_name}[] = {&VT_M{macro_name}};

{constructor}

void free_M{macro_name}(M{macro_name}* This)
{
    free(This);
}

{macro_builder}

void M{macro_name}_apply(M{macro_name}* This)
{
    exit(1);
}

{functions}
{End}

#========== macro_builder ==========
Macro macro_builder
    Param
        context_param : context_param;
        context_build_state : context_build_state, none="This->build_state";
        new_build_state : new_build_state, none="This->build_state = buildState";
        directive_calls : init_directive_call, separator="\n";
        internal_calls : init_internals_call, separator="\n";
        macro_body_parts : init_string_builder, string_part, param_insert_part,  eol_part, insert_macro_part(macro_name), add_indent(macro_name), indent_part, separator="\n";
    Internal
        macro_name : String;
{Body}
char* M{macro_name}_build(M{macro_name}* This, {context_param})
{
    BuildState *buildState = {context_build_state};

    if(buildState == NULL)
    {
        buildState = new_BuildState();
    }
    else if(buildState->vt->getExpansion(buildState) == NULL)
    {
        exit(1);
    }
    else
    {
        return buildState->vt->getExpansion();
    }
{Indent: "\t"}
{new_build_state};
{End}
    LinkedList *indentations = new_LinkedList();
    Stringbuilder sbIndentation = new_Stringbuilder(5);
{Indent: "\t"}
{directive_calls}
{internal_calls}
{End}

    Stringbuilder sb0 = new_Stringbuilder(5);

{Indent: "\t"}
{macro_body_parts}
{End}
    buildState->vt->setExpansion(sb0->vt->toString());
    return sb0->vt->toString();
}
{End}

#============ init_directive_call ============
Macro init_directive_call
    Param
        param_name: String;
{Body}
init{param_name}Directives();
{End}

#============ init_internals_call ============
Macro init_internals_call
    Param
        param_name: String;
        context_arg: context_arg, none="null";
{Body}
init{param_name}Internals({context_arg});
{End}

#========== context_build_state =======
Macro context_build_state
{Body}
This->build_states->vt->get(context)
{End}

#========== new_build_state =========
Macro new_build_state
{Body}
This->build_states->vt->put(context, buildState)
{End}

#========== redefined_apply_initializer ==========
Macro redefined_apply_initializer
    Internal
        macro_name : String;
{Body}
void M{macro_name}_apply(M{macro_name}* This, InternalsInitializer internalsInitializer)
{
    internalsInitializer->vt->setM{macro_name}(This);
}
{End}

#======================================================
#===================== CONSTRUCTOR ====================
#======================================================
Macro constructor_h
    Internal
        macro_name : String;
{Body}
M{macro_name}* new_M{macro_name}();
{End}

Macro constructor_c
    Param
        field_initializers : field_string_initializer(macro_name), field_macro_initializer(macro_name), separator="\n";
    Internal
        macro_name : String;
{Body}
M{macro_name}* new_M{macro_name}()
{
    M{macro_name}* macro = malloc(sizeof(M{macro_name}));
    macro->vt = &VT_M{macro_name};
{Indent: "\t"}
{field_initializers}
{End}
    return macro;
}
{End}
#================================================================
#===================== MACRO FUNCTIONS ==========================
#================================================================
#=========== is_built ===========
Macro is_built
{Body}
if(This->build_state != NULL){
    exit(1);
}
{End}

#============================
#========== Fields    =======
#============================

#========== field_string_declaration ==========
Macro field_string_declaration
    Param
        field_name : String;
{Body}
LinkedList *field_{field_name};
{End}

#========== field_string_initializer ==========
Macro field_string_initializer
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
{class_name}->field_{field_name} = new_LinkedList();
{End}

#========== field_macro_declaration ==========
Macro field_macro_declaration
    Param
        field_name : String;
{Body}
LinkedList *list_{field_name};
{End}

#========== field_macro_initializer ==========
Macro field_macro_initializer
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
{class_name}->list_{field_name} = new_LinkedList();
{End}


#============================
#========== Getter =======
#============================

#========== getter_string_vt_h ==========
Macro getter_string_vt_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
LinkedList* (*get{field_name})(struct M{class_name}*);
{End}

#========== getter_string_h ==========
Macro getter_string_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
LinkedList* M{class_name}_get{field_name}(struct M{class_name}*);
{End}

#========== getter_string_c ==========
Macro getter_string_c
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
LinkedList* M{class_name}_get{field_name}(struct M{class_name} *This)
{
    return This->{field_name};
}
{End}

#========== getter_macro_vt_h ==========
Macro getter_macro_vt_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* (*get{field_name})(struct M{class_name}*);
{End}

#========== getter_macro_h ==========
Macro getter_macro_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* M{class_name}_get{field_name}(struct M{class_name}*);
{End}

#========== getter_macro_c ==========
Macro getter_macro_c
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
char* M{class_name}_get{field_name}(struct M{class_name} *This)
{
    return This->{field_name};
}
{End}

#============================
#========== Setter =======
#============================

#========== setter_string_vt_h ==========
Macro setter_string_vt_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
void (*set{field_name})(struct M{class_name}*, char* value);
{End}

#========== setter_string_h ==========
Macro setter_string_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
void M{class_name}_set{field_name}(struct M{class_name}*, char* value);
{End}

#========== setter_string_c ==========
Macro setter_string_c
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
void M{class_name}_set{field_name}(struct M{class_name} *This, char* value)
{
    This->{field_name} = value;
}
{End}

#========= add_macro_vt_h ===========
Macro add_macro_vt_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
void (*add{field_name})(struct M{class_name}*, struct* M{field_name});
{End}

#========= add_macro_h ===========
Macro add_macro_h
    Param
        field_name : String;
    Internal
        class_name : String;
{Body}
void add{field_name}(struct M{class_name}*, struct* M{field_name});
{End}

#========= add_macro_c ===========
Macro add_macro_c
    Param
        field_name: String;
        is_built: is_built;
    Internal
        class_name: String;
{Body}
void add{field_name}(M{class_name}* This, M{field_name}* macro){
    if(macro == NULL){
        exit(1);
    }
{Indent: "\t"}
{is_built}
{End}

    This->list_{field_name}->append(macro);
    This->children->append(macro);
    //TODO Macro.cycleDetector.detectCycle(this, macro);
}
{End}

#============================
#========== Functions =======
#============================

Macro function_refs
    Param
        function_type : String;
        function_name : String;
    Internal
        macro_name : String;

{Body}
&M{macro_name}_{function_type}{function_name}
{End}

#============================
#========== Parts     =======
#============================

#========= string_part =================
Macro string_part
    Param
        string : String;
        index_builder : String;
{Body}
sb{index_builder}->vt->append("{string}");
{End}

#========= eol_part ===================
Macro eol_part
    Param
        index_builder : String;
{Body}
sb{index_builder}->vt->append(LINE_SEPARATOR);
{End}

#========== param_insert_part ==========
Macro param_insert_part
    Param
        param_name : String;
        index_builder : String;
        context_arg : context_arg;
{Body}
sb{index_builder}->vt->append(This->vt->build{param_name}({context_arg}));
{End}

#========== indent_part ===========
Macro indent_part
    Param
        index_builder : String;
        index_indent : String;
{Body}
sb{index_builder}->vt->append(applyIndent(sb{index_indent}->vt->toString(), indentations->vt->remove(indentations->size - 1)));
{End}

#========== insert_macro_part ===============
Macro insert_macro_part
    Param
        index_builder : String;
        index_insert : String;
        macro_body_parts : init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part(macro_name);
        set_internals : set_internal(macro_name);
    Internal
        macro_name : String;
{Body}
M{macro_name} minsert_{index_insert} = new M{macro_name}();
{macro_body_parts}
{set_internals}
sb{index_builder}.append(minsert_{index_insert}.build(null));
{End}

#========= init_string_builder =========
Macro init_string_builder
    Param
        index_builder : String;
{Body}
Stringbuilder sb{index_builder} = new_Stringbuilder(5);
{End}

#========== set_internal ==================
Macro set_internal
    Param
        param_name : String;
        context : String;
        set_params : param_ref(macro_name), string_builder_build;
    Internal
        macro_name : String;
{Body}
m{macro_name}->vt->set{param_name}({context}, {set_params});
{End}

#========== string_builder_build ==========
Macro string_builder_build
    Param
        index_builder : String;
{Body}
sb{index_builder}->vt->toString()
{End}

#=========== param_ref ===========
Macro param_ref
    Param
        name : String;
        get_params : context_arg, context_name;
    Internal
        macro_name : String;
{Body}
m{macro_name}->vt->get{name}({get_params})
{End}

#========= add_indent ===================
Macro add_indent
    Param
        macro_body_parts : init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part(macro_name);
    Internal
        macro_name : String;
{Body}
sbIndentation = new_Stringbuilder(5);
{macro_body_parts}
indentations->vt->add(sbIndentation->vt->toString());
{End}

#===================================================
#===================== OTHER =======================
#===================================================

#========== string_value ========
Macro string_value
  Param
    string : String;
{Body}
"{string}"
{End}

#=========== macro_arg ==========
Macro macro_arg
  Param
    name : String;
{Body}
list_{name}
{End}

#=========== string_arg =========
Macro string_arg
  Param
    name : String;
{Body}
field_{name}
{End}

#========== param_arg ==========
Macro param_arg
  Param
    name : String;
{Body}
p{name}
{End}

#=========== context_name =============
Macro context_name
  Param
    context_name : String;
{Body}
{context_name}
{End}

#======== context_param ============
Macro context_param
{Body}
Context context
{End}

#========= context_arg ============
Macro context_arg
{Body}
context
{End}

#=========== get_internal_tail ============
Macro get_internal_tail
{Body}
->vt->get(context)
{End}

#========== string_param ==========
Macro string_param
  Param
    name : String;
{Body}
char* p{name}
{End}