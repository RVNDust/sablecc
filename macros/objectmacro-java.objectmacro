$comment$
This file is part of SableCC ( http://sablecc.org ).

See the NOTICE file distributed with this work for copyright information.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
$end$

$comment: ========== header ========== $

$text: header $
/* This file was generated by SableCC's ObjectMacro. */
$end: header $
<<<<<<< HEAD

$comment: ========== package_declaration ========== $

$macro: package_declaration(package_name) $
package $package_name;
$end: package_declaration $

$comment: ========== import_java_util ========== $

$macro: import_java_util $
import java.util.*;
$end: import_java_util $

$comment: ========== context ============== $

=======

$comment: ========== package_declaration ========== $

$macro: package_declaration(package_name) $
package $package_name;
$end: package_declaration $

$comment: ========== import_java_util ========== $

$macro: import_java_util $
import java.util.*;
$end: import_java_util $

$comment: ========== context ============== $

>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
$macro: context $
$insert: header $
$expand: package_declaration, before_first="\n" $

public class Context {

}
$end: context $

$comment: ========== internals_initializer ========= $

$macro: internals_initializer $
$insert: header $
$expand: package_declaration, before_first="\n" $
$expand: import_java_util $

public class InternalsInitializer {

    private final String _paramName;

    InternalsInitializer(String paramName){
        this._paramName = paramName;
    }

$expand: parent_internals_setter, separator="\n" $

}
<<<<<<< HEAD
=======

$end: internals_initializer $

$comment: ========== parent_internals_setter ========= $

$macro: parent_internals_setter(name) $
    void set$name(M$name m$name){
        throw ObjectMacroException.incorrectType("M$name", this._paramName);
    }
$end: parent_internals_setter $

$comment: ========== super_macro ========== $

$macro: super_macro $
$insert: header $
$expand: package_declaration, before_first="\n" $
$expand: import_java_util $

public abstract class Macro {

    final static String LINE_SEPARATOR = System.getProperty("line.separator");

    BuildState build_state = null;

    final Map<Context, BuildState> build_states = new LinkedHashMap<>();

    public String build(){

        throw new RuntimeException("build cannot be invoked here");
    }

    String build(
            Context context){

        throw new RuntimeException("build cannot be invoked here");
    }

    void apply(
            InternalsInitializer internalsInitializer){

        throw new RuntimeException("apply cannot be called here");
    }

}
$end: super_macro $
>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1

$end: internals_initializer $

$comment: ========== parent_internals_setter ========= $

$macro: parent_internals_setter(name) $
    void set$name(M$name m$name){
        throw ObjectMacroException.incorrectType("M$name", this._paramName);
    }
$end: parent_internals_setter $

$comment: ========== super_macro ========== $

$macro: super_macro $
$insert: header $
$expand: package_declaration, before_first="\n" $
$expand: import_java_util $

public abstract class Macro {

    public final static String LINE_SEPARATOR = System.getProperty("line.separator");

    public String expansion;

    public Map<Context, String> expansions = new LinkedHashMap<>();

    public String build(){

        throw new RuntimeException("build cannot be invoked here");
    }

    String build(
            Context context){

        throw new RuntimeException("build cannot be invoked here");
    }

    void apply(
            InternalsInitializer internalsInitializer){

        throw new RuntimeException("apply cannot be called here");
    }

}
$end: super_macro $

<<<<<<< HEAD
$comment: =============== super_directive ============== $

$macro: super_directive $
$insert: header $
$expand: package_declaration, before_first="\n" $

abstract class Directive {

    final String value;

    Directive(
            String value) {

        this.value = value;
    }

    abstract String apply(Integer index, String macro, Integer list_size);
}
$end: super_directive $

<<<<<<< HEAD
$comment: =============== class_internal_value ========= $

$macro: class_internal_value $
$insert: header $
$expand: package_declaration, before_first="\n" $
$expand: import_java_util, before_first="\n" $

<<<<<<< HEAD
class InternalValue {

    private final List<Macro> macros;

    private final List<Directive> directives;

    private DNone dNone;

    private final Context context;

    private String cache;

    InternalValue(
            List<Macro> macros,
            Context context,
            List<Directive> directives){

        this.macros = macros;
        this.context = context;
        this.directives = directives;
    }

    String build(){

        if(this.cache != null){
            return this.cache;
        }

        StringBuilder sb = new StringBuilder();
        int i = 0;
        int nb_macros = this.macros.size();

        if(this.dNone != null){
            sb.append(this.dNone.apply(i, "", nb_macros));
        }

        for(Macro macro : this.macros){
            String expansion = macro.build(this.context);

            for(Directive directive : this.directives){
                expansion = directive.apply(i, expansion, nb_macros);
            }
            sb.append(expansion);
            i++;
        }

        this.cache = sb.toString();
        return this.cache;
    }

    List<Macro> getMacros(){
        return this.macros;
    }

    void setNone(DNone none){
        this.dNone = none;
    }
}

$end: class_internal_value $

$comment: =============== class_build_state ========= $

$macro: class_build_state $
$insert: header $
$expand: package_declaration, before_first="\n" $

class BuildState {

    private String expansion = null;

    public String getExpansion() {
        return expansion;
    }

    public void setExpansion(
            String expansion) {

        this.expansion = expansion;
    }
}

$end: class_build_state $

=======
>>>>>>> Add directives into InternalValue and update directives in order to easily add new directives
$comment: =============== class_internal_value ========= $

$macro: class_internal_value $
$insert: header $
$expand: package_declaration, before_first="\n" $
$expand: import_java_util, before_first="\n" $

class InternalValue {

    private final List<Macro> macros;

    private DAfterLast dAfterLast;

    private DBeforeFirst dBeforeFirst;

    private DSeparator dSeparator;

    private DNone dNone;

    private final Context context;

    private String cache;

    InternalValue(
            List<Macro> macros,
            Context context){

        this.macros = macros;
        this.context = context;
    }

    String build(){

        if(this.cache != null){
            return this.cache;
        }

        StringBuilder sb = new StringBuilder();
        int i = 0;
        int nb_macros = this.macros.size();

        if(this.dNone != null){
            sb.append(this.dNone.apply(i, "", nb_macros));
        }

        for(Macro macro : this.macros){
            String expansion = macro.build(this.context);

            if(this.dBeforeFirst != null){
                expansion = dBeforeFirst.apply(i, expansion, nb_macros);
            }

            if(dAfterLast != null){
                expansion = dAfterLast.apply(i, expansion, nb_macros);
            }

            if(this.dSeparator != null){
                expansion = dSeparator.apply(i, expansion, nb_macros);
            }

            sb.append(expansion);
            i++;
        }

        this.cache = sb.toString();
        return this.cache;
    }

    void setNone(
                DNone none){

        this.dNone = none;
    }

    void setBeforeFirst(
            DBeforeFirst dBeforeFirst){

        this.dBeforeFirst = dBeforeFirst;
    }

    void setAfterLast(
            DAfterLast dAfterLast){

        this.dAfterLast = dAfterLast;
    }

    void setSeparator(
            DSeparator dSeparator){

        this.dSeparator = dSeparator;
    }
}

$end: class_internal_value $

$comment: =============== class_build_state ========= $

$macro: class_build_state $
$insert: header $
$expand: package_declaration, before_first="\n" $

class BuildState {

    private String expansion = null;

    public String getExpansion() {
        return expansion;
    }

    public void setExpansion(
            String expansion) {

        this.expansion = expansion;
    }
}

$end: class_build_state $

=======
>>>>>>> Changement Objectmacro-back
$comment: ========== macro ========== $

$macro: macro(name) $
$insert: header $
$expand: package_declaration, before_first="\n" $
$expand: import_java_util, before_first="\n" $
=======
public class M$name extends Macro{
$expand: param_macro_field, param_string_field, internal_macro_field, internal_string_field, internal_macros_value_field, directive_fields, separator="\n", before_first="\n" $
$expand: context_field, before_first="\n" $
$expand: constructor, before_first="\n" $
$expand: param_string_setter, single_add, internal_string_setter, internal_macro_setter, before_first="\n", separator="\n" $
$expand: param_string_ref_builder, param_macro_ref_builder, internal_macro_ref_builder, separator="\n", before_first="\n" $
$expand: param_string_ref, param_macro_ref, internal_macro_ref, separator="\n", before_first="\n" $
$expand: init_internals_method, separator="\n" $
$expand: init_directives, separator="\n", before_first="\n"$
$expand: redefined_apply_initializer $
$expand: macro_builder, before_first="\n" $
<<<<<<< HEAD
>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1

public class M$name extends Macro{
$expand: param_macro_field, param_string_field, internal_macro_field, internal_string_field, separator="\n", before_first="\n" $
$expand: context_field, before_first="\n" $
$expand: constructor, before_first="\n" $
$expand: param_string_setter, param_macro_setter, internal_string_setter, internal_macro_setter, before_first="\n", separator="\n" $
$expand: param_string_ref_builder, param_macro_ref_builder, separator="\n", before_first="\n" $
$expand: param_string_ref, param_macro_ref, separator="\n", before_first="\n" $

$expand: redefined_apply_initializer $
$expand: macro_builder, before_first="\n" $
=======
>>>>>>> Now macro without internals has a builder with context that only return build
$expand: empty_builder_with_context, before_first="\n"$
}
$end: macro $

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
$comment$
======================================================
===================== CONSTRUCTOR ====================
======================================================
$end$
=======
=======
$comment$
======================================================
===================== CONSTRUCTOR ====================
======================================================
$end$

$comment: ========== constructor ========== $

$macro: constructor(name) $
    public M$name($expand: string_param, separator=", "$){
$expand: set_param, before_first="\n" $
$expand: init_macro_param, init_macro_internal, init_string_internal, before_first="\n" $
$expand: init_internal_value, before_first="\n"$
    }
$end: constructor $

$comment: ========== init_macro_internal =========== $

$macro: init_macro_internal(name) $
    this.list_$name = new LinkedHashMap<>();
$end: init_macro_internal $

$comment: ========== init_macro_param =========== $

$macro: init_macro_param(name) $
    this.list_$name = new ArrayList<>();
$end: init_macro_param $

$comment: ========== init_string_internal =========== $

$macro: init_string_internal(name) $
    this.field_$name = new LinkedHashMap<>();
$end: init_string_internal $

$comment: ========== init_internal_value ============ $

$macro: init_internal_value(param_name) $
    this.$(param_name)Value = new InternalValue(this.list_$param_name, this.$(param_name)Context);
$end: init_internal_value $

$comment: ========== set_param ========== $

$macro: set_param(name) $
        this.setP$name($expand: param_arg$);
$end: set_param $

$comment$
================================================================
===================== MACRO FUNCTIONS ==========================
================================================================
$end$

<<<<<<< HEAD
>>>>>>> Moved macros to get a better reading of the file
$comment: ========= add_all =========== $

$macro: add_all(param_name) $
    public void addAll$param_name(List<Macro> macros){
        if(macros == null){
            throw ObjectMacroException.parameterNull("$param_name");
        }
        $expand: is_built$

        int i = 0;

        for(Macro macro : macros){
            if(macro == null){
                throw ObjectMacroException.macroNull(i, "$param_name");
            }

            $expand: apply_internals_initializer $

            this.list_$param_name.add(macro);
            i++;
        }
    }
$end: add_all $

=======
>>>>>>> Removed add all function to keep only the static overload
$comment: ========= single_add =========== $

$macro: single_add(macro_name, param_name) $
    public void add$param_name(M$macro_name macro){
        if(macro == null){
            throw ObjectMacroException.parameterNull("$param_name");
        }
        $expand: is_built $

        this.list_$param_name.add(macro);
    }
$end: single_add $

$comment: =========== is_built =========== $

$macro: is_built(macro_name) $
        if(this.build_state != null){
            throw ObjectMacroException.cannotModify("$macro_name");
        }
$end: is_built $

$comment: =========== param_string_ref_builder ============= $

$macro: param_string_ref_builder(name) $
    private String build$name($expand: context_param$){

        return this.field_$(name)$expand: get_internal_tail $;
    }
$end: param_string_ref_builder $

$comment: ========== param_macro_ref_builder ================== $

$macro: param_macro_ref_builder(name) $
    private String build$name(){
        StringBuilder sb = new StringBuilder();
        Context local_context = $expand: context_name, none="context"$;
        List<Macro> macros = this.list_$name;

        int i = 0;
        int nb_macros = macros.size();
        String expansion = null;

        if(this.$(name)None != null){
            sb.append(this.$(name)None.apply(i, "", nb_macros));
        }

        for(Macro macro : macros){
            expansion = macro.build(local_context);

            if(this.$(name)BeforeFirst != null){
                expansion = this.$(name)BeforeFirst.apply(i, expansion, nb_macros);
            }

            if(this.$(name)AfterLast != null){
                expansion = this.$(name)AfterLast.apply(i, expansion, nb_macros);
            }

            if(this.$(name)Separator != null){
                expansion = this.$(name)Separator.apply(i, expansion, nb_macros);
            }

            sb.append(expansion);
            i++;
        }

        return sb.toString();
    }
$end: param_macro_ref_builder $

$comment: =========== internal_macro_ref_builder ================ $

$macro: internal_macro_ref_builder(internal_name) $
    private String build$internal_name(Context context){

        InternalValue macros = this.list_$(internal_name).get(context);
        return macros.build();
    }
$end: internal_macro_ref_builder $

$comment: ========= internal_macro_setter ========= $

$macro: internal_macro_setter(param_name) $
    void set$param_name(
            Context context,
            InternalValue internal_value) {

        if(internal_value == null){
            throw new RuntimeException("macros cannot be null");
        }

        this.list_$param_name.put(context, internal_value);
    }
$end: internal_macro_setter $

$comment: =========== param_string_setter ========= $

$macro: param_string_setter(name) $
    private void setP$name($expand: string_param $){
        if($expand: param_arg $ == null){
            throw ObjectMacroException.parameterNull("$name");
        }

        this.field_$name = $expand: param_arg $;
    }
$end: param_string_setter $

$comment: ========== param_macro_ref ============== $

$macro: param_macro_ref(name) $
    private InternalValue get$name(){
        return this.$(name)Value;
    }
$end: param_macro_ref $

$comment: ========== internal_macro_ref =========== $

$macro: internal_macro_ref(param_name) $
    private InternalValue get$param_name(Context context){
        return this.list_$(param_name).get(context);
    }
$end: internal_macro_ref $

$comment: ========== param_string_ref ============== $

$macro: param_string_ref(name) $
    private String get$name($expand: context_param $){

        return this.field_$(name)$expand: get_internal_tail $;
    }
$end: param_string_ref $

$comment: ========= internal_string_setter ========= $

$macro: internal_string_setter(name) $
    void set$name(
            Context context,
            String value) {

        if(value == null){
            throw new RuntimeException("value cannot be null here");
        }

        this.field_$name.put(context, value);
    }
$end: internal_string_setter $

$comment: ========= init_internals_method ======== $

$macro: init_internals_method(name) $
    private void init$(name)Internals(Context context){
        for(Macro macro : this.list_$name){
            $expand: apply_internals_initializer $
        }
    }
$end: init_internals_method $

$comment: ========== context_verifier ============ $

$macro: context_verifier $
        if(context == null){
            throw new RuntimeException("context cannot be null here");
        }
$end: context_verifier $

$comment: =========== init_directives =========== $

$macro: init_directives(param_name) $
    private void init$(param_name)Directives(){
        $macro: new_directive(directive_name, index_builder) $

        StringBuilder sb$index_builder = new StringBuilder();
        $expand: string_part, param_insert_part, eol_part, insert_macro_part $
        this.$(param_name)$(directive_name) = new D$(directive_name)(sb$index_builder.toString());
        this.$(param_name)Value.set$directive_name(this.$(param_name)$(directive_name));
        $end: new_directive $
    }
$end: init_directives $

$comment$
============================================
============== MACRO BUILDER ===============
============================================
$end$

$comment: ========= public ============= $

$macro: public $
public$no_eol$
$end: public $

=======
>>>>>>> Changement Objectmacro-back
$comment: ========== macro_builder ======= $
>>>>>>> AddAll and single adds with static overloads

<<<<<<< HEAD
$comment: ========== constructor ========== $

$macro: constructor(name) $
    public M$name($expand: string_param, separator=", "$){
$expand: set_param, before_first="\n" $
$expand: init_macro_param, init_macro_internal, init_string_internal, before_first="\n" $
$expand: init_internal_value, before_first="\n"$
    }
$end: constructor $

<<<<<<< HEAD
$comment: ========== init_macro_internal =========== $

<<<<<<< HEAD
$macro: init_macro_internal(name) $
    this.list_$name = new LinkedHashMap<>();
$end: init_macro_internal $
=======
        $expand: build_verification $
=======
$macro: macro_builder(macro_name) $
=======
$macro: macro_builder $
>>>>>>> Changement Objectmacro-back
    @Override
    $expand: public $ String build($expand: context_param $){

        String local_expansion = $expand: context_expansion, none="this.expansion"$;

        if(local_expansion != null){
            return local_expansion;
        }
<<<<<<< HEAD
        else if(buildState.getExpansion() == null){
            throw ObjectMacroException.cyclicReference("$macro_name");
        }
        else{
            return buildState.getExpansion();
        }
        $expand: new_build_state, none="this.build_state = buildState" $;
>>>>>>> Add BuildState class in order to do a cheap cycle verification on build method

        $macro: init_directives_call(param_name) $
        init$(param_name)Directives();
        $end: init_directives_call $

        $macro: init_internals_call(param_name) $
        init$(param_name)Internals($expand: context_arg, none="null"$);
        $end: init_internals_call $
=======
>>>>>>> Changement Objectmacro-back

        StringBuilder sb0 = new StringBuilder();
>>>>>>> Init internals before building the macro instead at the add or addAll methods

$comment: ========== init_macro_param =========== $

<<<<<<< HEAD
$macro: init_macro_param(name) $
    this.list_$name = new ArrayList<>();
$end: init_macro_param $

<<<<<<< HEAD
<<<<<<< HEAD
$comment: ========== init_string_internal =========== $
=======
=======
$comment: ============ build_verification ============ $

$macro: build_verification(macro_name) $
        if(this.built){
            throw ObjectMacroException.cyclicReference("$macro_name");
        }
        this.built = true;
$end: build_verification $

<<<<<<< HEAD
>>>>>>> Init internals before building the macro instead at the add or addAll methods
=======
        buildState.setExpansion(sb0.toString());
        return sb0.toString();
=======
        local_expansion = sb0.toString();
        $expand: new_context_expansion, none="this.expansion = local_expansion" $;
        return local_expansion;
>>>>>>> Changement Objectmacro-back
    }
$end: macro_builder $

>>>>>>> Add BuildState class in order to do a cheap cycle verification on build method
$comment: ============ empty_builder_with_context ============ $

$macro: empty_builder_with_context $
    @Override
    String build(Context context) {
        return build();
    }
$end: empty_builder_with_context$

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
$comment: ========= public ============= $
>>>>>>> Now macro without internals has a builder with context that only return build

$macro: init_string_internal(name) $
    this.field_$name = new LinkedHashMap<>();
$end: init_string_internal $

$comment: ========== init_internal_value ============ $
=======
$comment: ========== context_expansion ======= $
>>>>>>> Moved macros to get a better reading of the file

$macro: init_internal_value(param_name) $
    this.$(param_name)Value = new InternalValue(this.list_$param_name, this.$(param_name)Context, this.$(param_name)Directives);
$end: init_internal_value $

$comment: ========== set_param ========== $

$macro: set_param(name) $
        this.setP$name($expand: param_arg$);
$end: set_param $
=======
$comment: ========== context_build_state ======= $
=======
$comment: ========= public ============= $

$macro: public $
public$no_eol$
$end: public $
>>>>>>> Changement Objectmacro-back

$comment: ========== context_expansion ======= $

$macro: context_expansion $
this.expansions.get(context)$no_eol$
$end: context_expansion $

<<<<<<< HEAD
$macro: new_build_state $
this.build_states.put(context, buildState)$no_eol$
$end: new_build_state $
>>>>>>> Add BuildState class in order to do a cheap cycle verification on build method
=======
$comment: ========== new_context_expansion ========= $

$macro: new_context_expansion $
this.expansions.put(context, local_expansion)$no_eol$
$end: new_context_expansion $
>>>>>>> Changement Objectmacro-back

$comment$
================================================================
===================== MACRO FUNCTIONS ==========================
================================================================
$end$

$comment: ========= add_all =========== $

$macro: add_all(param_name) $
    public void addAll$param_name(List<Macro> macros){
        if(macros == null){
            throw ObjectMacroException.parameterNull("$param_name");
        }
        $expand: is_built$

<<<<<<< HEAD
<<<<<<< HEAD
        int i = 0;
=======
$comment: ========= init_internals_method ======== $

$macro: init_internals_method(name) $
    private void init$(name)Internals(){
        for(Macro macro : this.list_$name){
            $expand: apply_internals_initializer $
        }
    }
$end: init_internals_method $

$comment: =========== init_internals_call ======== $

<<<<<<< HEAD
<<<<<<< HEAD
$macro: init_internals_call(param_name) $
init$(param_name)Internals();
$end: init_internals_call $
=======
=======
$comment: =========== init_internals_call ======== $

$macro: init_internals_call(param_name) $
init$(param_name)Internals($expand: context_arg, none="null"$);
$end: init_internals_call $

<<<<<<< HEAD
>>>>>>> Lazy initialization in build method instead of eager initialization in add methods
=======
>>>>>>> Add directives into InternalValue and update directives in order to easily add new directives
$comment$
===================================================
================= MACRO FIELDS ====================
===================================================
$end$
>>>>>>> Moved macros to get a better reading of the file

=======
>>>>>>> Changement Objectmacro-back
$comment: ========== param_macro_field ========== $
>>>>>>> Init internals before building the macro instead at the add or addAll methods

<<<<<<< HEAD
        for(Macro macro : macros){
            if(macro == null){
                throw ObjectMacroException.macroNull(i, "$param_name");
            }
=======
$macro: param_macro_field(name) $
    private Macro list_$name[];
$end: param_macro_field $
>>>>>>> Removed in constructor initialization and add lazy initialization

            $expand: apply_internals_initializer $

            this.list_$param_name.add(macro);
            i++;
        }
    }
$end: add_all $

<<<<<<< HEAD
$comment: ========= single_add =========== $

<<<<<<< HEAD
$macro: single_add(macro_name, param_name) $
    public void add$param_name(M$macro_name macro){
        if(macro == null){
            throw ObjectMacroException.parameterNull("$param_name");
        }
        $expand: is_built $
=======
$macro: internal_macro_field(name) $
    private Map<Context, InternalValue> list_$name = new LinkedHashMap<>();
$end: internal_macro_field $
>>>>>>> Removed in constructor initialization and add lazy initialization

        this.list_$param_name.add(macro);
    }
$end: single_add $

$comment: =========== is_built =========== $

$macro: is_built(macro_name) $
        if(this.build_state != null){
            throw ObjectMacroException.cannotModify("$macro_name");
        }
$end: is_built $

$comment: =========== param_string_ref_builder ============= $

<<<<<<< HEAD
<<<<<<< HEAD
$macro: param_string_ref_builder(name) $
    private String build$name($expand: context_param$){
=======
$comment: =========== param_macros_value_field ======== $
<<<<<<< HEAD
$comment: ========== constructor ========== $
>>>>>>> Add param macro list values in OM 1

<<<<<<< HEAD
        return this.field_$(name)$expand: get_internal_tail $;
=======
$macro: constructor(name) $
    public M$name($expand: string_param, separator=", "$){
$expand: set_param, before_first="\n" $
<<<<<<< HEAD
$expand: init_macro_internal, init_string_internal, before_first="\n" $
>>>>>>> Removed in constructor initialization and add lazy initialization
=======
$expand: init_macro_param, init_macro_internal, init_string_internal, before_first="\n" $
>>>>>>> Init internals before building the macro instead at the add or addAll methods
    }
$end: param_string_ref_builder $
=======
>>>>>>> Moved macros to get a better reading of the file

<<<<<<< HEAD
$comment: ========== param_macro_ref_builder ================== $
=======
$macro: param_macros_value_field(param_name) $
    private final MacrosValue $param_nameValue;
$end: param_macros_value_field $
<<<<<<< HEAD
$comment: ========== string_param ========== $
>>>>>>> Add param macro list values in OM 1

$macro: param_macro_ref_builder(name, index_builder) $
    private String build$name(){
        StringBuilder sb$index_builder = new StringBuilder();
        Context local_context = $expand: context_name, none="context"$;
        List<Macro> macros = this.list_$name;

<<<<<<< HEAD
        int i = 0;
        int nb_macros = macros.size();
        String expansion = null;

        $macro: apply_none_directive $
        if(this.$(name)None != null){
            sb$index_builder.append(this.$(name)None.apply(i, "", nb_macros));
        }
        $end: apply_none_directive $
=======
$comment: ========== list_macro_param ========== $
=======

$comment: ========== init_macro_internal =========== $
>>>>>>> Moved macros to get a better reading of the file

$macro: init_macro_internal(name) $
    this.list_$name = new LinkedHashMap<>();
$end: init_macro_internal $

$comment: ========== init_macro_param =========== $

<<<<<<< HEAD
$macro: macro_param(name) $
Macro p$(name)$no_eol$
$end: macro_param $
>>>>>>> Removed in constructor initialization and add lazy initialization

        for(Macro macro : macros){
            expansion = macro.build(local_context);
            for(Directive directive : this.$(name)Directives){
                expansion = directive.apply(i, expansion, nb_macros);
            }

            sb$index_builder.append(expansion);
            i++;
        }

        return sb$index_builder.toString();
    }
$end: param_macro_ref_builder $

$comment: =========== internal_macro_ref_builder ================ $

<<<<<<< HEAD
$macro: internal_macro_ref_builder(internal_name) $
    private String build$internal_name(Context context){

        InternalValue macros = this.list_$(internal_name).get(context);
        return macros.build();
    }
$end: internal_macro_ref_builder $

$comment: ========= internal_macro_setter ========= $

$macro: internal_macro_setter(param_name) $
    void set$param_name(
            Context context,
            InternalValue internal_value) {

        if(internal_value == null){
            throw new RuntimeException("macros cannot be null");
        }

        this.list_$param_name.put(context, internal_value);
    }
$end: internal_macro_setter $

$comment: =========== param_string_setter ========= $

$macro: param_string_setter(name) $
    private void setP$name($expand: string_param $){
        if($expand: param_arg $ == null){
            throw ObjectMacroException.parameterNull("$name");
        }

        this.field_$name = $expand: param_arg $;
    }
$end: param_string_setter $

$comment: ========== param_macro_ref ============== $

$macro: param_macro_ref(name) $
    private InternalValue get$name(){
        return this.$(name)Value;
    }
$end: param_macro_ref $

$comment: ========== internal_macro_ref =========== $

$macro: internal_macro_ref(param_name) $
    private InternalValue get$param_name(Context context){
        return this.list_$(param_name).get(context);
    }
$end: internal_macro_ref $

$comment: ========== param_string_ref ============== $

$macro: param_string_ref(name) $
    private String get$name($expand: context_param $){

        return this.field_$(name)$expand: get_internal_tail $;
    }
$end: param_string_ref $

$comment: ========= internal_string_setter ========= $

$macro: internal_string_setter(name) $
    void set$name(
            Context context,
            String value) {

        if(value == null){
            throw new RuntimeException("value cannot be null here");
        }

        this.field_$name.put(context, value);
    }
$end: internal_string_setter $

$comment: ========= init_internals_method ======== $

$macro: init_internals_method(name) $
    private void init$(name)Internals(Context context){
        for(Macro macro : this.list_$name){
            $expand: apply_internals_initializer $
        }
    }
$end: init_internals_method $

$comment: ========== context_verifier ============ $

$macro: context_verifier $
        if(context == null){
            throw new RuntimeException("context cannot be null here");
        }
$end: context_verifier $

$comment: =========== init_directives =========== $

$macro: init_directives(param_name) $
    private void init$(param_name)Directives(){
        $expand: new_directive, set_none_directive $
    }
$end: init_directives $

$comment: =========== new_directive ============ $

$macro: new_directive(param_name, directive_name, index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$expand: string_part, param_insert_part, eol_part, insert_macro_part $
        this.$(param_name)Directives.add(new D$(directive_name)(sb$index_builder.toString()));
$end: new_directive $

$comment: =========== set_none_directive ======== $

$macro: set_none_directive(param_name, index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$expand: string_part, param_insert_part, eol_part, insert_macro_part $
        this.$(param_name)Value.setNone(new DNone(sb$index_builder.toString()));
        this.$(param_name)None = new DNone(sb$index_builder.toString());
$end: set_none_directive $

$comment$
============================================
============== MACRO BUILDER ===============
============================================
$end$

$comment: ========= public ============= $

$macro: public $
public$no_eol$
$end: public $

$comment: ========== macro_builder ======= $

$macro: macro_builder(macro_name) $
    @Override
    $expand: public $ String build($expand: context_param $){

        BuildState buildState = $expand: context_build_state, none="this.build_state"$;

        if(buildState == null){
            buildState = new BuildState();
        }
        else if(buildState.getExpansion() == null){
            throw ObjectMacroException.cyclicReference("$macro_name");
        }
        else{
            return buildState.getExpansion();
        }
        $expand: new_build_state, none="this.build_state = buildState" $;

        $macro: init_directives_call(param_name) $
        init$(param_name)Directives();
        $end: init_directives_call $

        $macro: init_internals_call(param_name) $
        init$(param_name)Internals($expand: context_arg, none="null"$);
        $end: init_internals_call $

        StringBuilder sb0 = new StringBuilder();

$expand: string_part, param_insert_part, eol_part, insert_macro_part $

        buildState.setExpansion(sb0.toString());
        return sb0.toString();
    }
$end: macro_builder $

$comment: ============ empty_builder_with_context ============ $

$macro: empty_builder_with_context $
    @Override
    String build(Context context) {
        return build();
    }
$end: empty_builder_with_context$

$comment: ========== context_build_state ======= $

$macro: context_build_state $
this.build_states.get(context)$no_eol$
$end: context_build_state $

$comment: ========== new_build_state ========= $

$macro: new_build_state $
this.build_states.put(context, buildState)$no_eol$
$end: new_build_state $

$comment: ========= redefined_apply_initializer ======= $

$macro: redefined_apply_initializer(name) $
    @Override
    void apply(
            InternalsInitializer internalsInitializer){

        internalsInitializer.set$name(this);
    }
$end: redefined_apply_initializer $

$comment$
===================================================
================= MACRO FIELDS ====================
===================================================
$end$

$comment: ========== param_macro_field ========== $

$macro: param_macro_field(name) $
    private final List<Macro> list_$name;
=======
$comment: ========== macro_builder ======= $

$macro: macro_builder $
    @Override
    $expand: public $ String build($expand: context_param $){

        String local_expansion = $expand: context_expansion, none="this.expansion"$;

        if(local_expansion != null){
            return local_expansion;
        }

        StringBuilder sb0 = new StringBuilder();

$expand: string_part, param_insert_part, eol_part, insert_macro_part $

        local_expansion = sb0.toString();
        $expand: new_context_expansion, none="this.expansion = local_expansion" $;
        return local_expansion;
    }
$end: macro_builder $

$comment: ========= public ============= $

$macro: public $
public$no_eol$
$end: public $

$comment: ========== context_expansion ======= $

$macro: context_expansion $
this.expansions.get(context)$no_eol$
$end: context_expansion $

$comment: ========== new_context_expansion ========= $

$macro: new_context_expansion $
this.expansions.put(context, local_expansion)$no_eol$
$end: new_context_expansion $

$comment: ========= redefined_apply_initializer ======= $

$macro: redefined_apply_initializer(name) $
    @Override
    void apply(
            InternalsInitializer internalsInitializer){

        internalsInitializer.set$name(this);
    }
$end: redefined_apply_initializer $

$comment: ========== param_macro_field ========== $

$macro: param_macro_field(name) $
    private Macro list_$name[];
>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
$end: param_macro_field $

$comment: ========== param_string_field ========== $

$macro: param_string_field(name) $
    private String field_$name;
$end: param_string_field $

$comment: ========== internal_macro_field ========== $

$macro: internal_macro_field(name) $
<<<<<<< HEAD
    private Map<Context, InternalValue> list_$name = new LinkedHashMap<>();
=======
    private Map<Context, Macro[]> list_$name = new LinkedHashMap<>();
>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
=======
$macro: internal_macro_field(name) $
    private Map<Context, Macro[]> list_$name = new LinkedHashMap<>();
>>>>>>> Changement Objectmacro-back
$end: internal_macro_field $

$comment: ========== internal_string_field ========== $

$macro: internal_string_field(name) $
    private Map<Context, String> field_$name = new LinkedHashMap<>();
$end: internal_string_field $

$comment: ========== context_field ========= $

$macro: context_field(name) $
    private final Context $(name)Context = new Context();
$end: context_field $

<<<<<<< HEAD
$comment: =========== internal_macros_value_field ======== $

$macro: internal_macros_value_field(param_name) $
    private final InternalValue $(param_name)Value;
$end: internal_macros_value_field $

$comment: ========== string_param ========== $

=======
$comment: ========== constructor ========== $

$macro: constructor(name) $
    public M$name($expand: string_param, macro_param, separator=", "$){
$expand: set_param, before_first="\n" $
$expand: init_macro_internal, init_string_internal, before_first="\n" $
    }
$end: constructor $

$comment: ========== string_param ========== $

>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
$macro: string_param(name) $
String p$(name)$no_eol$
$end: string_param $

<<<<<<< HEAD
$comment: ========== directives_field ========= $

$macro: directives_field(param_name) $
    private final List<Directive> $(param_name)Directives = new ArrayList<>();
$end: directives_field $

$comment: ========== none_directive_field ========= $

$macro: none_directive_field(param_name) $
    private DNone $(param_name)None;
$end: none_directive_field $

$comment$
============================================
========== ADAPTER TO SET INTERNALS ========
============================================
$end$

$comment: ========== apply_internals_initializer ======= $

$macro: apply_internals_initializer(param_name) $
macro.apply(new InternalsInitializer("$param_name"){
$expand: redefined_internals_setter $
});
$end: apply_internals_initializer $

$comment: ========== redefined_internals_setter ========= $

$macro: redefined_internals_setter(name) $
@Override
void set$name(M$name m$name){

    $expand: init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part, separator="\n" $
    $expand: set_internal $
}
$end: redefined_internals_setter $

$comment$
===================================================
=============== MACRO / TEXT PARTS ================
===================================================
$end$

$comment: ========= string_part ================= $

=======
$comment: ========== macro_param ========== $

$macro: macro_param(name) $
Macro p$(name)[]$no_eol$
$end: macro_param $

$comment: =========== param_string_setter ========= $

$macro: param_string_setter(name) $
    private void setP$name($expand: string_param $){
        if($expand: param_arg $ == null){
            throw ObjectMacroException.parameterNull("$name");
        }

        this.field_$name = $expand: param_arg $;
    }
$end: param_string_setter $

$comment: ========= param_macro_setter =========== $

$macro: param_macro_setter(name) $
    private void setP$name($expand: macro_param $){
        if($expand: param_arg $ == null){
            throw ObjectMacroException.parameterNull("$name");
        }

        Macro macros[] = $expand: param_arg $;
        this.list_$name = new Macro[macros.length];
        int i = 0;

        for(Macro macro : macros){
            if(macro == null){
                throw ObjectMacroException.macroNull(i, "$name");
            }

            $expand: apply_internals_initializer $

            this.list_$name[i++] = macro;

        }
    }
$end: param_macro_setter $

$comment: ========= internal_macro_setter ========= $

$macro: internal_macro_setter(name) $
    void set$name(
            Context context,
            Macro macros[]) {

        if(macros == null){
            throw new RuntimeException("macros cannot be null here");
        }

        Macro[] tempMacros = new Macro[macros.length];
        int i = 0;

        for(Macro macro : macros){

            if(macro == null){
                throw ObjectMacroException.macroNull(i, "$name");
            }

            $expand: apply_internals_initializer $

            tempMacros[i++] = macro;
        }

        this.list_$name.put(context, tempMacros);
    }
$end: internal_macro_setter $


$comment: ========== apply_internals_initializer ======= $

$macro: apply_internals_initializer(param_name) $
macro.apply(new InternalsInitializer("$param_name"){
    $expand: redefined_internals_setter $
});
$end: apply_internals_initializer $

$comment: ========== redefined_internals_setter ========= $

$macro: redefined_internals_setter(name) $
    @Override
    void set$name(M$name m$name){

        $expand: init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part, separator="\n" $
        $expand: set_internal $
    }
$end: redefined_internals_setter $

$comment: ========== string_value ======== $

$macro: string_value(string) $
"$string"$no_eol$
$end: string_value $

$comment: =========== macro_arg ========== $

$macro: macro_arg(name) $
list_$(name)$no_eol$
$end: macro_arg $

$comment: =========== string_arg ========= $

$macro: string_arg(name) $
field_$(name)$no_eol$
$end: string_arg $

$comment: ========== set_param ========== $

$macro: set_param(name) $
        this.setP$name($expand: param_arg$);
$end: set_param $

$comment: ========== param_arg ========== $

$macro: param_arg(name) $
p$(name)$no_eol$
$end: param_arg $

$comment: ========= string_part ================= $

>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
$macro: string_part(string, index_builder) $
        sb$index_builder.append("$string");
$end: string_part $

$comment: ========= eol_part =================== $

$macro: eol_part(index_builder) $
        sb$index_builder.append(LINE_SEPARATOR);
$end: eol_part $

$comment: ========== param_insert_part ========== $

$macro:  param_insert_part(param_name, index_builder) $
        sb$index_builder.append(build$param_name($expand: context_arg $));
$end: param_insert_part $

<<<<<<< HEAD
=======
$comment: ========= init_string_builder ========= $

$macro: init_string_builder(index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$end: init_string_builder $

>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
$comment: ========== insert_macro_part =============== $

$macro: insert_macro_part(name, index_builder, index_insert) $
        M$name minsert_$index_insert = new M$name();
        $expand: init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part $
        $expand: set_internal $
        sb$index_builder.append(minsert_$index_insert.build(null));
$end: insert_macro_part $

<<<<<<< HEAD
$comment: ========= init_string_builder ========= $

$macro: init_string_builder(index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$end: init_string_builder $

$comment: ========== set_internal ================== $

$macro: set_internal(macro_name, param_name, context)   $
        m$macro_name.set$param_name($context, $expand: param_ref, string_builder_build $);
=======
$comment: ========== set_internal ================== $

$macro: set_internal(macro_name, param_name, context)   $
        m$macro_name.set$param_name($context, $expand: macro_arg, string_builder_build $);
>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
$end: set_internal $

$comment: ========== string_builder_build ========== $

$macro: string_builder_build(index_builder) $
sb$index_builder.toString()$no_eol$
$end: string_builder_build $

<<<<<<< HEAD
$comment: =========== param_ref =========== $

$macro: param_ref(name) $
get$name($expand: context_arg, context_name$)$no_eol$
$end: param_ref $

$comment$
===================================================
===================== OTHER =======================
===================================================
$end$

$comment: ========== string_value ======== $

$macro: string_value(string) $
"$string"$no_eol$
$end: string_value $

$comment: =========== macro_arg ========== $

$macro: macro_arg(name) $
list_$(name)$no_eol$
$end: macro_arg $

$comment: =========== string_arg ========= $

$macro: string_arg(name) $
field_$(name)$no_eol$
$end: string_arg $

$comment: ========== param_arg ========== $

<<<<<<< HEAD
$macro: param_arg(name) $
p$(name)$no_eol$
$end: param_arg $
=======
$comment: ========== param_macro_ref ================== $

$macro: param_macro_ref(name, index_builder) $
    private String build$name(
            $expand: context_param $){

        StringBuilder sb$index_builder = new StringBuilder();
        Context local_context = $expand: context_name, none="context"$;
        Macro macros[] = this.list_$(name)$expand: get_internal_tail $;
        $expand: none $
        boolean first = true;
        int i = 0;
=======
    final static String LINE_SEPARATOR = System.getProperty("line.separator");

    BuildState build_state = null;

    final Map<Context, BuildState> build_states = new LinkedHashMap<>();
>>>>>>> Revert "Changement Objectmacro-back"

<<<<<<< HEAD
        for(Macro macro : macros){
            $expand: before_first $
            $expand: separator $

            sb$index_builder.append(macro.build(local_context));
            i++;

            $expand: after_last $
        }

        return sb$index_builder.toString();
    }
$end: param_macro_ref $
>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1

$comment: =========== context_name ============= $

$macro: context_name(context_name) $
$(context_name)$no_eol$
$end: context_name $

<<<<<<< HEAD
$comment: ======== context_param ============ $

<<<<<<< HEAD
$macro: context_param $
Context context$no_eol$
$end: context_param $
=======
$comment: =============== super_directive ============== $

$macro: super_directive $
$insert: header $
$expand: package_declaration, before_first="\n" $

abstract class Directive {

    final String value;

    Directive(
            String value) {

        this.value = value;
    }

    abstract String apply(Integer index, String macro, Integer list_size);
}
$end: super_directive $

$comment: =============== class_internal_value ========= $

$macro: class_internal_value $
$insert: header $
$expand: package_declaration, before_first="\n" $
$expand: import_java_util, before_first="\n" $

class InternalValue {

    private final List<Macro> macros;

    private final List<Directive> directives;

    private DNone dNone;

    private final Context context;

    InternalValue(
            List<Macro> macros,
            Context context,
            List<Directive> directives){

        this.macros = macros;
        this.context = context;
        this.directives = directives;
    }

    String build(){

        StringBuilder sb = new StringBuilder();
        int i = 0;
        int nb_macros = this.macros.size();

        if(this.dNone != null){
            sb.append(this.dNone.apply(i, "", nb_macros));
        }

        for(Macro macro : this.macros){
            String expansion = macro.build(this.context);

            for(Directive directive : this.directives){
                expansion = directive.apply(i, expansion, nb_macros);
            }
            sb.append(expansion);
            i++;
        }

        return sb.toString();
    }

    List<Macro> getMacros(){
        return this.macros;
    }

    void setNone(DNone none){
        this.dNone = none;
    }
}

$end: class_internal_value $

$comment: =============== class_build_state ========= $

$macro: class_build_state $
$insert: header $
$expand: package_declaration, before_first="\n" $

class BuildState {

    private String expansion = null;

    public String getExpansion() {
        return expansion;
    }

    public void setExpansion(
            String expansion) {

        this.expansion = expansion;
    }
}

$end: class_build_state $

$comment: ========== macro ========== $
>>>>>>> Revert "Changement Objectmacro-back"

$comment: ========= context_arg ============ $

<<<<<<< HEAD
$macro: context_arg $
context$no_eol$
$end: context_arg $

$comment: =========== get_internal_tail ============ $

$macro: get_internal_tail $
.get(context)$no_eol$
$end: get_internal_tail $

$comment$
===================================================
===================== DIRECTIVES ==================
===================================================
$end$

$comment: =========== class_none ============ $

$macro: class_none $
$insert: header $
$expand: package_declaration, before_first="\n" $
=======
public class M$name extends Macro{
$expand: param_macro_field, param_string_field, internal_macro_field, internal_string_field, internal_macros_value_field, directives_field, none_directive_field, separator="\n", before_first="\n" $
$expand: context_field, before_first="\n" $
$expand: constructor, before_first="\n" $
$expand: param_string_setter, add_all, single_add, internal_string_setter, internal_macro_setter, before_first="\n", separator="\n" $
$expand: param_string_ref_builder, param_macro_ref_builder, internal_macro_ref_builder, separator="\n", before_first="\n" $
$expand: param_string_ref, param_macro_ref, internal_macro_ref, separator="\n", before_first="\n" $
$expand: init_internals_method, separator="\n" $
$expand: init_directives, separator="\n", before_first="\n"$
$expand: redefined_apply_initializer $
$expand: macro_builder, before_first="\n" $
$expand: empty_builder_with_context, before_first="\n"$
}
$end: macro $

$comment$
======================================================
===================== CONSTRUCTOR ====================
======================================================
$end$

$comment: ========== constructor ========== $

$macro: constructor(name) $
    public M$name($expand: string_param, separator=", "$){
$expand: set_param, before_first="\n" $
$expand: init_macro_param, init_macro_internal, init_string_internal, before_first="\n" $
$expand: init_internal_value, before_first="\n"$
    }
$end: constructor $

$comment: ========== init_macro_internal =========== $

$macro: init_macro_internal(name) $
    this.list_$name = new LinkedHashMap<>();
$end: init_macro_internal $

$comment: ========== init_macro_param =========== $

$macro: init_macro_param(name) $
    this.list_$name = new ArrayList<>();
$end: init_macro_param $

$comment: ========== init_string_internal =========== $

$macro: init_string_internal(name) $
    this.field_$name = new LinkedHashMap<>();
$end: init_string_internal $

$comment: ========== init_internal_value ============ $

$macro: init_internal_value(param_name) $
    this.$(param_name)Value = new InternalValue(this.list_$param_name, this.$(param_name)Context, this.$(param_name)Directives);
$end: init_internal_value $

$comment: ========== set_param ========== $

$macro: set_param(name) $
        this.setP$name($expand: param_arg$);
$end: set_param $

$comment$
================================================================
===================== MACRO FUNCTIONS ==========================
================================================================
$end$

$comment: ========= add_all =========== $

$macro: add_all(param_name) $
    public void addAll$param_name(List<Macro> macros){
        if(macros == null){
            throw ObjectMacroException.parameterNull("$param_name");
        }
        $expand: is_built$

        int i = 0;

        for(Macro macro : macros){
            if(macro == null){
                throw ObjectMacroException.macroNull(i, "$param_name");
            }

            $expand: apply_internals_initializer $

            this.list_$param_name.add(macro);
            i++;
        }
    }
$end: add_all $

$comment: ========= single_add =========== $

$macro: single_add(macro_name, param_name) $
    public void add$param_name(M$macro_name macro){
        if(macro == null){
            throw ObjectMacroException.parameterNull("$param_name");
        }
        $expand: is_built $

        this.list_$param_name.add(macro);
    }
$end: single_add $

$comment: =========== is_built =========== $

$macro: is_built(macro_name) $
        if(this.build_state != null){
            throw ObjectMacroException.cannotModify("$macro_name");
        }
$end: is_built $

$comment: =========== param_string_ref_builder ============= $

$macro: param_string_ref_builder(name) $
    private String build$name($expand: context_param$){

        return this.field_$(name)$expand: get_internal_tail $;
    }
$end: param_string_ref_builder $

$comment: ========== param_macro_ref_builder ================== $

$macro: param_macro_ref_builder(name, index_builder) $
    private String build$name(){
        StringBuilder sb$index_builder = new StringBuilder();
        Context local_context = $expand: context_name, none="context"$;
        List<Macro> macros = this.list_$name;

        int i = 0;
        int nb_macros = macros.size();
        String expansion = null;

        $macro: apply_none_directive $
        if(this.$(name)None != null){
            sb$index_builder.append(this.$(name)None.apply(i, "", nb_macros));
        }
        $end: apply_none_directive $

        for(Macro macro : macros){
            expansion = macro.build(local_context);
            for(Directive directive : this.$(name)Directives){
                expansion = directive.apply(i, expansion, nb_macros);
            }

            sb$index_builder.append(expansion);
            i++;
        }

        return sb$index_builder.toString();
    }
$end: param_macro_ref_builder $

$comment: =========== internal_macro_ref_builder ================ $

$macro: internal_macro_ref_builder(internal_name) $
    private String build$internal_name(Context context){

        InternalValue macros = this.list_$(internal_name).get(context);
        return macros.build();
    }
$end: internal_macro_ref_builder $

$comment: ========= internal_macro_setter ========= $

$macro: internal_macro_setter(param_name) $
    void set$param_name(
            Context context,
            InternalValue internal_value) {

        if(internal_value == null){
            throw new RuntimeException("macros cannot be null");
        }

        this.list_$param_name.put(context, internal_value);
    }
$end: internal_macro_setter $

$comment: =========== param_string_setter ========= $

$macro: param_string_setter(name) $
    private void setP$name($expand: string_param $){
        if($expand: param_arg $ == null){
            throw ObjectMacroException.parameterNull("$name");
        }

        this.field_$name = $expand: param_arg $;
    }
$end: param_string_setter $

$comment: ========== param_macro_ref ============== $

$macro: param_macro_ref(name) $
    private InternalValue get$name(){
        return this.$(name)Value;
    }
$end: param_macro_ref $

$comment: ========== internal_macro_ref =========== $

$macro: internal_macro_ref(param_name) $
    private InternalValue get$param_name(Context context){
        return this.list_$(param_name).get(context);
    }
$end: internal_macro_ref $

$comment: ========== param_string_ref ============== $

$macro: param_string_ref(name) $
    private String get$name($expand: context_param $){

        return this.field_$(name)$expand: get_internal_tail $;
    }
$end: param_string_ref $

$comment: ========= internal_string_setter ========= $

$macro: internal_string_setter(name) $
    void set$name(
            Context context,
            String value) {

        if(value == null){
            throw new RuntimeException("value cannot be null here");
        }

        this.field_$name.put(context, value);
    }
$end: internal_string_setter $

$comment: ========= init_internals_method ======== $

$macro: init_internals_method(name) $
    private void init$(name)Internals(Context context){
        for(Macro macro : this.list_$name){
            $expand: apply_internals_initializer $
        }
    }
$end: init_internals_method $

$comment: ========== context_verifier ============ $

$macro: context_verifier $
        if(context == null){
            throw new RuntimeException("context cannot be null here");
        }
$end: context_verifier $

$comment: =========== init_directives =========== $

$macro: init_directives(param_name) $
    private void init$(param_name)Directives(){
        $expand: new_directive, set_none_directive $
    }
$end: init_directives $

$comment: =========== new_directive ============ $

$macro: new_directive(param_name, directive_name, index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$expand: string_part, param_insert_part, eol_part, insert_macro_part $
        this.$(param_name)Directives.add(new D$(directive_name)(sb$index_builder.toString()));
$end: new_directive $

$comment: =========== set_none_directive ======== $

$macro: set_none_directive(param_name, index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$expand: string_part, param_insert_part, eol_part, insert_macro_part $
        this.$(param_name)Value.setNone(new DNone(sb$index_builder.toString()));
        this.$(param_name)None = new DNone(sb$index_builder.toString());
$end: set_none_directive $

$comment$
============================================
============== MACRO BUILDER ===============
============================================
$end$

$comment: ========= public ============= $

$macro: public $
public$no_eol$
$end: public $

$comment: ========== macro_builder ======= $

$macro: macro_builder(macro_name) $
    @Override
    $expand: public $ String build($expand: context_param $){

        BuildState buildState = $expand: context_build_state, none="this.build_state"$;

        if(buildState == null){
            buildState = new BuildState();
        }
        else if(buildState.getExpansion() == null){
            throw ObjectMacroException.cyclicReference("$macro_name");
        }
        else{
            return buildState.getExpansion();
        }
        $expand: new_build_state, none="this.build_state = buildState" $;

        $macro: init_directives_call(param_name) $
        init$(param_name)Directives();
        $end: init_directives_call $

        $macro: init_internals_call(param_name) $
        init$(param_name)Internals($expand: context_arg, none="null"$);
        $end: init_internals_call $
>>>>>>> Revert "Changement Objectmacro-back"

class DNone
        extends Directive{

    DNone(String value) {

<<<<<<< HEAD
        super(value);
=======
        buildState.setExpansion(sb0.toString());
        return sb0.toString();
>>>>>>> Revert "Changement Objectmacro-back"
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(list_size == 0){
            return this.value;
        }

        return macro;
    }
}
$end: class_none $

<<<<<<< HEAD
$comment: ========== class_before_first ========= $

$macro: class_before_first $
$insert: header $
$expand: package_declaration, before_first="\n" $

<<<<<<< HEAD
class DBeforeFirst
        extends Directive {
=======
$macro: param_macro_setter(name) $
    public void setP$name($expand: list_macro_param $){
        if($expand: param_arg $ == null){
            throw ObjectMacroException.parameterNull("$name");
=======
$macro: param_macro_setter(param_name, macro_name) $
    public void addAllP$param_name(List<Macro> macros){
        if(macros == null){
            throw ObjectMacroException.parameterNull("$param_name");
        }
        if(this.built){
            throw ObjectMacroException.cannotModify("$macro_name");
>>>>>>> Init internals before building the macro instead at the add or addAll methods
        }

        int i = 0;
>>>>>>> Removed in constructor initialization and add lazy initialization

<<<<<<< HEAD
    DBeforeFirst(String value) {
=======
        for(Macro macro : macros){
            if(macro == null){
                throw ObjectMacroException.macroNull(i, "$param_name");
            }
>>>>>>> Init internals before building the macro instead at the add or addAll methods

        super(value);
    }
=======
$macro: init_macro_param(name) $
    this.list_$name = new ArrayList<>();
$end: init_macro_param $
=======
$comment: ========== context_build_state ======= $

$macro: context_build_state $
this.build_states.get(context)$no_eol$
$end: context_build_state $

$comment: ========== new_build_state ========= $

$macro: new_build_state $
this.build_states.put(context, buildState)$no_eol$
$end: new_build_state $
>>>>>>> Revert "Changement Objectmacro-back"

$comment: ========== init_string_internal =========== $

$macro: init_string_internal(name) $
    this.field_$name = new LinkedHashMap<>();
$end: init_string_internal $

>>>>>>> Moved macros to get a better reading of the file

<<<<<<< HEAD
<<<<<<< HEAD
    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == 0){
            return this.value.concat(macro);
        }
        return macro;
=======
            this.list_$name.add(macro);

=======
            this.list_$param_name.add(macro);
            i++;
>>>>>>> Init internals before building the macro instead at the add or addAll methods
        }
    }
=======

<<<<<<< HEAD
=======
$comment: =========== internal_macros_value_field ======== $
>>>>>>> Add structure which contains list of macros and the context associated

$macro: internal_macros_value_field(param_name) $
    private final InternalValue $(param_name)Value;
$end: internal_macros_value_field $
=======
$comment$
===================================================
================= MACRO FIELDS ====================
===================================================
$end$

$comment: ========== param_macro_field ========== $

$macro: param_macro_field(name) $
    private final List<Macro> list_$name;
$end: param_macro_field $
>>>>>>> Revert "Changement Objectmacro-back"

$comment: ========== string_param ========== $

$macro: string_param(name) $
String p$(name)$no_eol$
$end: string_param $

<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> AddAll and single adds with static overloads
=======
$comment: =========== is_built =========== $
>>>>>>> Moved macros to get a better reading of the file

<<<<<<< HEAD
$macro: is_built(macro_name) $
        if(this.build_state != null){
            throw ObjectMacroException.cannotModify("$macro_name");
        }
<<<<<<< HEAD
=======
$macro: internal_macro_field(name) $
    private Map<Context, InternalValue> list_$name = new LinkedHashMap<>();
$end: internal_macro_field $
>>>>>>> Revert "Changement Objectmacro-back"

<<<<<<< HEAD
        $expand: apply_internals_initializer $

<<<<<<< HEAD
        this.list_$name.add(macro);
>>>>>>> Removed in constructor initialization and add lazy initialization
=======
        this.list_$param_name.add(macro);
>>>>>>> Init internals before building the macro instead at the add or addAll methods
    }
}

$end: class_before_first $

<<<<<<< HEAD
$comment: ========== class_after_last ========== $
=======
$comment: ========= internal_macro_setter ========= $
>>>>>>> AddAll and single adds with static overloads

<<<<<<< HEAD
$macro: class_after_last $
$insert: header $
$expand: package_declaration, before_first="\n" $

<<<<<<< HEAD
class DAfterLast
        extends Directive {
=======
$macro: internal_macro_setter(name) $
    void set$name(
=======
$macro: internal_macro_setter(param_name) $
    void set$param_name(
>>>>>>> Init internals before building the macro instead at the add or addAll methods
            Context context,
            List<Macro> macros) {

<<<<<<< HEAD
        if(macros == null){
            throw new RuntimeException("macros cannot be null");
        }
=======
$comment: ========== constructor ========== $

$macro: constructor(name) $
    public M$name($expand: string_param, macro_param, separator=", "$){
$expand: set_param, before_first="\n" $
$expand: init_macro_internal, init_string_internal, before_first="\n" $
    }
$end: constructor $
>>>>>>> Changement Objectmacro-back
=======
$comment: =========== internal_macros_value_field ======== $

$macro: internal_macros_value_field(param_name) $
    private final InternalValue $(param_name)Value;
$end: internal_macros_value_field $
>>>>>>> Revert "Changement Objectmacro-back"

        final List<Macro> tempMacros = new ArrayList<>();
        int i = 0;
>>>>>>> Removed in constructor initialization and add lazy initialization

<<<<<<< HEAD
    DAfterLast(String value) {

<<<<<<< HEAD
        super(value);
    }
=======
            if(macro == null){
                throw ObjectMacroException.macroNull(i, "param_name");
            }
>>>>>>> Init internals before building the macro instead at the add or addAll methods

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

<<<<<<< HEAD
        if(index == list_size - 1){
            return macro.concat(this.value);
=======
            tempMacros.add(macro);
>>>>>>> Removed in constructor initialization and add lazy initialization
        }
<<<<<<< HEAD
        return macro;
=======

        this.list_$param_name.put(context, tempMacros);
>>>>>>> Init internals before building the macro instead at the add or addAll methods
    }
}
$end: class_after_last $

<<<<<<< HEAD
$comment: ======== class_separator =========== $
=======
$end: is_built $
>>>>>>> Moved macros to get a better reading of the file
=======
$comment: ========== directives_field ========= $
=======
$comment: ========== macro_param ========== $

$macro: macro_param(name) $
Macro p$(name)[]$no_eol$
$end: macro_param $

$comment: =========== param_string_setter ========= $

$macro: param_string_setter(name) $
    private void setP$name($expand: string_param $){
        if($expand: param_arg $ == null){
            throw ObjectMacroException.parameterNull("$name");
        }

        this.field_$name = $expand: param_arg $;
    }
$end: param_string_setter $

$comment: ========= param_macro_setter =========== $

$macro: param_macro_setter(name) $
    private void setP$name($expand: macro_param $){
        if($expand: param_arg $ == null){
            throw ObjectMacroException.parameterNull("$name");
        }

        Macro macros[] = $expand: param_arg $;
        this.list_$name = new Macro[macros.length];
        int i = 0;

        for(Macro macro : macros){
            if(macro == null){
                throw ObjectMacroException.macroNull(i, "$name");
            }

            $expand: apply_internals_initializer $

            this.list_$name[i++] = macro;

        }
    }
$end: param_macro_setter $

<<<<<<< HEAD
$comment: ========= internal_macro_setter ========= $

$macro: internal_macro_setter(name) $
    void set$name(
            Context context,
            Macro macros[]) {

        if(macros == null){
            throw new RuntimeException("macros cannot be null here");
        }

        Macro[] tempMacros = new Macro[macros.length];
        int i = 0;

        for(Macro macro : macros){
>>>>>>> Changement Objectmacro-back

            if(macro == null){
                throw ObjectMacroException.macroNull(i, "$name");
            }
=======
$comment: ========== directive_fields ========== $

$macro: directive_fields(param_name) $
    private DSeparator $(param_name)Separator;

    private DBeforeFirst $(param_name)BeforeFirst;

    private DAfterLast $(param_name)AfterLast;

    private DNone $(param_name)None;
$end: directive_fields $
>>>>>>> Remove abstraction on directives when building a macro or a parameter
=======
$macro: string_param(name) $
String p$(name)$no_eol$
$end: string_param $

$comment: ========== directives_field ========= $
>>>>>>> Revert "Changement Objectmacro-back"

$macro: directives_field(param_name) $
    private final List<Directive> $(param_name)Directives = new ArrayList<>();
$end: directives_field $

$comment: ========== none_directive_field ========= $

$macro: none_directive_field(param_name) $
    private DNone $(param_name)None;
$end: none_directive_field $

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> Revert "Changement Objectmacro-back"
$comment$
============================================
========== ADAPTER TO SET INTERNALS ========
============================================
$end$
<<<<<<< HEAD
>>>>>>> Add directives into InternalValue and update directives in order to easily add new directives
=======
>>>>>>> Changement Objectmacro-back
=======
>>>>>>> Revert "Changement Objectmacro-back"

$macro: class_separator $
$insert: header $
$expand: package_declaration, before_first="\n" $

<<<<<<< HEAD
class DSeparator
        extends Directive {
=======
$macro: apply_internals_initializer(param_name) $
macro.apply(new InternalsInitializer("$param_name"){
$expand: redefined_internals_setter $
});
$end: apply_internals_initializer $
>>>>>>> Allow to set internals with string and macro by adding a structure containing the macro and parameters and internals name

    DSeparator(String value) {

        super(value);
    }

<<<<<<< HEAD
    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(list_size == 0 || index == list_size - 1){
            return macro;
        }

        return macro.concat(this.value);
    }
}
$end: class_separator $
=======
$macro: redefined_internals_setter(name) $
@Override
void set$name(M$name m$name){

    $expand: init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part, separator="\n" $
    $expand: set_internal $
}
$end: redefined_internals_setter $
>>>>>>> Allow to set internals with string and macro by adding a structure containing the macro and parameters and internals name

<<<<<<< HEAD
$comment$
=========================================================
=====================  EXCEPTIONS =======================
=========================================================
$end$

$comment: ============ object_macro_exception =========== $

$macro: object_macro_exception $
$insert: header $
$expand: package_declaration, before_first="\n"$

public class ObjectMacroException
        extends RuntimeException{

<<<<<<< HEAD
    private ObjectMacroException(
            String message){

        super(message);

<<<<<<< HEAD
        if(message == null){
            throw new RuntimeException("message may not be null");
        }
    }

    private ObjectMacroException(
            String message,
            Throwable cause) {

        super(message, cause);
=======
$comment: ========== param_arg ========== $
>>>>>>> Add structure which contains list of macros and the context associated

        if (message == null) {
            throw new RuntimeException("message may not be null");
        }

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        if (cause == null) {
            throw new RuntimeException("cause may not be null");
        }
    }
=======
=======
=======
>>>>>>> Add directives into InternalValue and update directives in order to easily add new directives
$comment$
>>>>>>> Add structure which contains list of macros and the context associated
=======
$comment$
>>>>>>> Revert "Changement Objectmacro-back"
===================================================
=============== MACRO / TEXT PARTS ================
===================================================
$end$
<<<<<<< HEAD
=======
$comment: ========== string_value ======== $

$macro: string_value(string) $
"$string"$no_eol$
$end: string_value $

$comment: =========== macro_arg ========== $

$macro: macro_arg(name) $
list_$(name)$no_eol$
$end: macro_arg $

$comment: =========== string_arg ========= $

$macro: string_arg(name) $
field_$(name)$no_eol$
$end: string_arg $

$comment: ========== set_param ========== $

$macro: set_param(name) $
        this.setP$name($expand: param_arg$);
$end: set_param $

$comment: ========== param_arg ========== $

$macro: param_arg(name) $
p$(name)$no_eol$
$end: param_arg $
>>>>>>> Changement Objectmacro-back
=======
>>>>>>> Revert "Changement Objectmacro-back"

$comment: ========= string_part ================= $
>>>>>>> Moved macros to get a better reading of the file

    static ObjectMacroException incorrectType(
            String type,
            String param_name){


        return new ObjectMacroException(
                new MIncorrectType(type, param_name).toString());
    }

    static ObjectMacroException macroNull(
            Integer index,
            String paramName){

        return new ObjectMacroException(
                new MMacroNullInList(String.valueOf(index), paramName).toString());
    }

<<<<<<< HEAD
<<<<<<< HEAD
    static ObjectMacroException parameterNull(
            String paramName){

        return new ObjectMacroException(new MParameterNull(paramName).toString());
    }

<<<<<<< HEAD
    static ObjectMacroException cyclicReference(
            String macroName){
=======
=======
$comment: ========= init_string_builder ========= $

$macro: init_string_builder(index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$end: init_string_builder $

>>>>>>> Changement Objectmacro-back
=======
>>>>>>> Revert "Changement Objectmacro-back"
$comment: ========== insert_macro_part =============== $
>>>>>>> Moved macros to get a better reading of the file

        return new ObjectMacroException(new MCyclicReference(macroName).toString());
    }

<<<<<<< HEAD
<<<<<<< HEAD
    static ObjectMacroException cannotModify(
            String macroName){
=======
$comment: ========= init_string_builder ========= $

$macro: init_string_builder(index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$end: init_string_builder $

<<<<<<< HEAD
=======
>>>>>>> Changement Objectmacro-back
=======
$comment: ========= init_string_builder ========= $

$macro: init_string_builder(index_builder) $
        StringBuilder sb$index_builder = new StringBuilder();
$end: init_string_builder $

>>>>>>> Revert "Changement Objectmacro-back"
$comment: ========== set_internal ================== $
>>>>>>> Moved macros to get a better reading of the file

<<<<<<< HEAD
        return new ObjectMacroException(new MCannotModify(macroName).toString());
    }
=======
$macro: set_internal(macro_name, param_name, context)   $
        m$macro_name.set$param_name($context, $expand: param_ref, string_builder_build $);
$end: set_internal $
>>>>>>> Allow to set internals with string and macro by adding a structure containing the macro and parameters and internals name

}
$end: object_macro_exception $

$macro: incorrect_type $
$insert: header $
$expand: package_declaration, before_first="\n" $

<<<<<<< HEAD
public class MIncorrectType {

<<<<<<< HEAD
  private final String pType;
  private final String pParamName;
  private final MIncorrectType mIncorrectType = this;
=======
$comment: ========== param_macro_ref_builder ================== $

$macro: param_macro_ref_builder(name, index_builder) $
    private String build$name($expand: context_param $){
>>>>>>> Allow to set internals with string and macro by adding a structure containing the macro and parameters and internals name

<<<<<<< HEAD
  public MIncorrectType(String pType, String pParamName) {
    if(pType == null) throw new NullPointerException();
    this.pType = pType;
    if(pParamName == null) throw new NullPointerException();
    this.pParamName = pParamName;
  }
=======
        StringBuilder sb$index_builder = new StringBuilder();
        Context local_context = $expand: context_name, none="context"$;
        List<Macro> macros = this.list_$(name)$expand: get_internal_tail $;
        $expand: none $
        boolean first = true;
        int i = 0;
>>>>>>> Removed in constructor initialization and add lazy initialization

<<<<<<< HEAD
  String pType() {
    return this.pType;
  }

  String pParamName() {
    return this.pParamName;
  }

  private String rType() {
    return this.mIncorrectType.pType();
  }

<<<<<<< HEAD
  private String rParamName() {
    return this.mIncorrectType.pParamName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(new MObjectMacroErrorHead().toString());
    sb.append(System.getProperty("line.separator"));
    sb.append(rType());
    sb.append(" was not expected in parameter '");
    sb.append(rParamName());
    sb.append("'.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }
=======
        return sb$index_builder.toString();
    }
$end: param_macro_ref_builder $

$comment: =========== param_string_ref_builder ============= $

$macro: param_string_ref_builder(name) $
    private String build$name($expand: context_param$){

        return this.field_$(name)$expand: get_internal_tail $;
    }
$end: param_string_ref_builder $

$comment: ========== param_macro_ref ============== $

$macro: param_macro_ref(name) $
    private List<Macro> get$name($expand: context_param $){

        return this.list_$(name)$expand: get_internal_tail $;
    }
$end: param_macro_ref $

$comment: ========== param_string_ref ============== $

<<<<<<< HEAD
$macro: param_string_ref(name) $
    private String get$name($expand: context_param $){

        return this.field_$(name)$expand: get_internal_tail $;
    }
$end: param_string_ref $

=======
>>>>>>> Moved macros to get a better reading of the file
$comment: =========== param_ref =========== $

$macro: param_ref(name) $
get$name($expand: context_arg, context_name$)$no_eol$
$end: param_ref $

$comment$
===================================================
===================== OTHER =======================
===================================================
$end$
=======
$comment: ========== param_macro_ref_builder ================== $
>>>>>>> Changement Objectmacro-back
=======
$comment: =========== param_ref =========== $
>>>>>>> Revert "Changement Objectmacro-back"

$macro: param_ref(name) $
get$name($expand: context_arg, context_name$)$no_eol$
$end: param_ref $

$comment$
===================================================
===================== OTHER =======================
===================================================
$end$

$comment: ========== string_value ======== $

$macro: string_value(string) $
"$string"$no_eol$
$end: string_value $

$comment: =========== macro_arg ========== $

$macro: macro_arg(name) $
list_$(name)$no_eol$
$end: macro_arg $

$comment: =========== string_arg ========= $

$macro: string_arg(name) $
field_$(name)$no_eol$
$end: string_arg $

<<<<<<< HEAD
<<<<<<< HEAD
$comment: =========== context_name ============= $
>>>>>>> Allow to set internals with string and macro by adding a structure containing the macro and parameters and internals name

}
$end: incorrect_type $

$comment: ============== object_macro_error_head =========== $

<<<<<<< HEAD
=======
$comment: =========== none ============ $
=======
$comment: ======== context_param ============ $
>>>>>>> Add directives into InternalValue and update directives in order to easily add new directives
=======
        return this.field_$(name)$expand: get_internal_tail $;
    }
$end: param_string_ref_builder $
=======
$comment: ========== param_arg ========== $
>>>>>>> Revert "Changement Objectmacro-back"

$macro: param_arg(name) $
p$(name)$no_eol$
$end: param_arg $

<<<<<<< HEAD
$macro: param_macro_ref(name) $
    private Macro[] get$name($expand: context_param $){
>>>>>>> Changement Objectmacro-back
=======
$comment: =========== context_name ============= $
>>>>>>> Revert "Changement Objectmacro-back"

$macro: context_name(context_name) $
$(context_name)$no_eol$
$end: context_name $

<<<<<<< HEAD
<<<<<<< HEAD
$comment: ========== param_string_ref ============== $
=======
$comment: ========== string_param ========== $

$macro: string_param(name) $
String p$(name)$no_eol$
$end: string_param $


$comment$
===================================================
===================== DIRECTIVES ==================
===================================================
$end$
>>>>>>> Remove abstraction on directives when building a macro or a parameter
=======
$comment: ======== context_param ============ $
>>>>>>> Revert "Changement Objectmacro-back"

$macro: context_param $
Context context$no_eol$
$end: context_param $

$comment: ========= context_arg ============ $

$macro: context_arg $
context$no_eol$
$end: context_arg $

$comment: =========== get_internal_tail ============ $

$macro: get_internal_tail $
.get(context)$no_eol$
$end: get_internal_tail $

$comment$
===================================================
===================== DIRECTIVES ==================
===================================================
$end$

$comment: =========== class_none ============ $

$macro: class_none $
$insert: header $
$expand: package_declaration, before_first="\n" $

class DNone
        extends Directive{

    DNone(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(list_size == 0){
            return this.value;
        }

        return macro;
    }
}
$end: class_none $

$comment: ========== class_before_first ========= $

$macro: class_before_first $
$insert: header $
$expand: package_declaration, before_first="\n" $

class DBeforeFirst
        extends Directive {

    DBeforeFirst(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == 0){
            return this.value.concat(macro);
        }
        return macro;
    }
}

$end: class_before_first $

$comment: ========== class_after_last ========== $

$macro: class_after_last $
$insert: header $
$expand: package_declaration, before_first="\n" $

class DAfterLast
        extends Directive {

    DAfterLast(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == list_size - 1){
            return macro.concat(this.value);
        }
        return macro;
    }
}
$end: class_after_last $

$comment: ======== class_separator =========== $

<<<<<<< HEAD
<<<<<<< HEAD
$macro: init_macro_internal(name) $
    this.list_$name = new LinkedHashMap<>();
$end: init_macro_internal $
=======
        if(index == list_size - 1){
            return macro;
        }
>>>>>>> Remove abstraction on directives when building a macro or a parameter
=======
$macro: class_separator $
$insert: header $
$expand: package_declaration, before_first="\n" $
>>>>>>> Revert "Changement Objectmacro-back"

class DSeparator
        extends Directive {

    DSeparator(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(list_size == 0 || index == list_size - 1){
            return macro;
        }

        return macro.concat(this.value);
    }
}
$end: class_separator $

$comment$
=========================================================
=====================  EXCEPTIONS =======================
=========================================================
$end$

$comment: ============ object_macro_exception =========== $

$macro: object_macro_exception $
$insert: header $
$expand: package_declaration, before_first="\n"$

public class ObjectMacroException
        extends RuntimeException{

    private ObjectMacroException(
            String message){

        super(message);

        if(message == null){
            throw new RuntimeException("message may not be null");
        }
    }

    private ObjectMacroException(
            String message,
            Throwable cause) {

        super(message, cause);

        if (message == null) {
            throw new RuntimeException("message may not be null");
        }

        if (cause == null) {
            throw new RuntimeException("cause may not be null");
        }
    }

    static ObjectMacroException incorrectType(
            String type,
            String param_name){


        return new ObjectMacroException(
                new MIncorrectType(type, param_name).toString());
    }

    static ObjectMacroException macroNull(
            Integer index,
            String paramName){

        return new ObjectMacroException(
                new MMacroNullInList(String.valueOf(index), paramName).toString());
    }

    static ObjectMacroException parameterNull(
            String paramName){

        return new ObjectMacroException(new MParameterNull(paramName).toString());
    }

    static ObjectMacroException cyclicReference(
            String macroName){

        return new ObjectMacroException(new MCyclicReference(macroName).toString());
    }

    static ObjectMacroException cannotModify(
            String macroName){

        return new ObjectMacroException(new MCannotModify(macroName).toString());
    }

}
$end: object_macro_exception $

$macro: incorrect_type $
$insert: header $
$expand: package_declaration, before_first="\n" $

public class MIncorrectType {

  private final String pType;
  private final String pParamName;
  private final MIncorrectType mIncorrectType = this;

  public MIncorrectType(String pType, String pParamName) {
    if(pType == null) throw new NullPointerException();
    this.pType = pType;
    if(pParamName == null) throw new NullPointerException();
    this.pParamName = pParamName;
  }

  String pType() {
    return this.pType;
  }

  String pParamName() {
    return this.pParamName;
  }

  private String rType() {
    return this.mIncorrectType.pType();
  }

  private String rParamName() {
    return this.mIncorrectType.pParamName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(new MObjectMacroErrorHead().toString());
    sb.append(System.getProperty("line.separator"));
    sb.append(rType());
    sb.append(" was not expected in parameter '");
    sb.append(rParamName());
    sb.append("'.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
$end: incorrect_type $

$comment: ============== object_macro_error_head =========== $

>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
$macro: object_macro_error_head $
$insert: header $
$expand: package_declaration, before_first="\n" $

class MObjectMacroErrorHead {

  MObjectMacroErrorHead() {
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("*** OBJECT MACRO ERROR ***");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
$end: object_macro_error_head $

$comment: =============== parameter_null ============== $

$macro: parameter_null $
$insert: header $
$expand: package_declaration, before_first="\n" $

public class MParameterNull {

  private final String pParamName;
  private final MParameterNull mParameterNull = this;

  public MParameterNull(String pParamName) {
    if(pParamName == null) throw new NullPointerException();
    this.pParamName = pParamName;
  }

  String pParamName() {
    return this.pParamName;
  }

  private String rParamName() {
    return this.mParameterNull.pParamName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("Parameter '");
    sb.append(rParamName());
    sb.append("' cannot be null.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}

$end: parameter_null $

$comment: ============ macro_null_in_list ============ $

$macro: macro_null_in_list $
$insert: header $
$expand: package_declaration, before_first="\n" $

public class MMacroNullInList {

  private final String pIndex;
  private final String pParamName;
  private final MMacroNullInList mMacroNullInList = this;

  public MMacroNullInList(String pIndex, String pParamName) {
    if(pIndex == null) throw new NullPointerException();
    this.pIndex = pIndex;
    if(pParamName == null) throw new NullPointerException();
    this.pParamName = pParamName;
  }

  String pIndex() {
    return this.pIndex;
  }

  String pParamName() {
    return this.pParamName;
  }

  private String rIndex() {
    return this.mMacroNullInList.pIndex();
  }

  private String rParamName() {
    return this.mMacroNullInList.pParamName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("A macro is null at index ");
    sb.append(rIndex());
    sb.append(" in the list '");
    sb.append(rParamName());
    sb.append("'.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
$end: macro_null_in_list $
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> Init internals before building the macro instead at the add or addAll methods
=======
>>>>>>> Revert "Changement Objectmacro-back"

$comment: ============ cannot_modify ============ $

$macro: cannot_modify $
$insert: header $
$expand: package_declaration, before_first="\n" $

public class MCannotModify {

  private final String pMacroName;
  private final MCannotModify mCannotModify = this;

  public MCannotModify(String pMacroName) {
    if(pMacroName == null) throw new NullPointerException();
    this.pMacroName = pMacroName;
  }

  String pMacroName() {
    return this.pMacroName;
  }

  private String rMacroName() {
    return this.mCannotModify.pMacroName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(new MObjectMacroErrorHead().toString());
    sb.append(System.getProperty("line.separator"));
    sb.append("Instance of M");
    sb.append(rMacroName());
    sb.append(" cannot be updated after calling the method built.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
$end: cannot_modify $

$comment: ============ cyclic_reference ============ $

$macro: cyclic_reference $
$insert: header $
$expand: package_declaration, before_first="\n" $

public class MCyclicReference {

  private final String pMacroName;
  private final MCyclicReference mCyclicReference = this;

  public MCyclicReference(String pMacroName) {
    if(pMacroName == null) throw new NullPointerException();
    this.pMacroName = pMacroName;
  }

  String pMacroName() {
    return this.pMacroName;
  }

  private String rMacroName() {
    return this.mCyclicReference.pMacroName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(new MObjectMacroErrorHead().toString());
    sb.append(System.getProperty("line.separator"));
    sb.append("An instance of \\"");
    sb.append(rMacroName());
    sb.append("\\" is a cyclic reference to the same instance.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
$end: cyclic_reference $
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> Java code generation Objectmacro 2 using the lib ObjectMacro 1
=======
>>>>>>> Init internals before building the macro instead at the add or addAll methods
=======
>>>>>>> Changement Objectmacro-back
=======
>>>>>>> Revert "Changement Objectmacro-back"
